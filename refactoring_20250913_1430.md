# A2A Demo SPA 개발 리팩토링 계획

## 작업의 목적

A2A(Agent to Agent) 시연을 위한 애니메이션 기반 SPA 개발을 통해 다음을 달성:

- 3단계 A2A 진화 과정(A2H → Lite Agent → Full A2A)의 시각적 시연
- 실시간 시나리오 편집 및 30fps MP4 녹화 기능
- 16:9 비율의 전문적인 데모 환경 제공
- 8개 핵심 시나리오의 인터랙티브 애니메이션 구현

## 현재의 상태 / 문제점

### 현재 상태

- 기본 Vite + TypeScript 프로젝트 구조
- Framer Motion, Zustand 의존성 설치 완료
- 상세한 시나리오 문서(8개 시나리오) 및 UI 요구사항 정의됨

### 주요 문제점

1. **아키텍처 부재**: 컴포넌트 구조 및 상태 관리 패턴 미정의
2. **3-섹션 레이아웃 부재**: 수평 3개 섹션(사용자-AI Agent-서비스제공자) 구조 미구현
3. **UI 컴포넌트 부재**: iPhone 스타일 UI, 메시지 시스템 등 핵심 컴포넌트 미구현
4. **애니메이션 시스템 부재**: JSON 기반 시나리오 엔진 및 시퀀싱 로직 부재
5. **녹화 시스템 부재**: MediaRecorder API 통합 및 16:9 캡처 기능 부재
6. **반응형 레이아웃 부재**: ControlHeader와 DemoView 분리 구조 미구현

## 추가 분석 과제

### 1. MediaRecorder API 호환성 (✅ 검증 완료)

**브라우저 지원 현황:**

- **Chrome 49+**: 완전 지원 (H.264 코덱 포함)
- **Firefox 25+**: 완전 지원 (최신 버전 권장)
- **Safari 14.1+**: 완전 지원 (iOS 14+ 포함)
- **Edge 79+**: 완전 지원

**핵심 발견사항:**

- H.264 코덱은 모든 주요 브라우저에서 30fps 녹화 지원
- Chrome과 Edge에서 가장 안정적인 성능 보장
- Safari는 14.1+ 버전에서 완전 호환 (모바일 포함)
- MIME 타입 `video/mp4; codecs="avc1.42E01E"` 권장

### 2. Framer Motion 성능 최적화 전략 (✅ 검증 완료)

**복잡한 3섹션 애니메이션 최적화 방법:**

- **Layout 애니메이션 최적화**: `will-change: auto !important` 사용으로 GPU 가속 제어
- **Optimized Appear 애니메이션**: `startOptimizedAppearAnimation` API 활용으로 SSR 호환성 확보
- **Performance 모니터링**: `onLayoutAnimationStart`, `onAnimationComplete` 콜백으로 성능 추적
- **Frame Drop 방지**: Layout 애니메이션과 Transform 애니메이션 분리 실행

**권장 구현 패턴:**

```typescript
// 3섹션 동기화를 위한 성능 최적화 패턴
const sectionTransition = {
  duration: 0.5,
  ease: "linear",
  layout: { ease: () => 0, duration: 10 }, // 빠른 layout 전환
};
```

### 3. 반응형 16:9 레이아웃 기술 (✅ 검증 완료)

**CSS Grid + Flexbox 하이브리드 접근법:**

```css
.demo-view {
  aspect-ratio: 16/9; /* 네이티브 지원 */
  display: grid;
  grid-template-columns: 1fr 1fr 1fr; /* 3등분 섹션 */
  container-type: inline-size; /* Container Queries 지원 */
}

/* Fallback for older browsers */
@supports not (aspect-ratio: 16/9) {
  .demo-view {
    padding-top: 56.25%; /* 16:9 ratio */
    position: relative;
  }
}
```

**반응형 전략:**

- Container Queries 활용으로 미디어쿼리 최소화
- CSS Grid `auto-fit` 활용한 유연한 섹션 크기 조정
- `clamp()` 함수로 스무스한 타이포그래피 스케일링

### 4. 시나리오 데이터 구조 설계 (✅ 검증 완료)

**Zod 기반 런타임 검증 시스템:**

```typescript
// 2025년 최신 Zod 패턴 적용
const ScenarioStepSchema = z.object({
  id: z.string().uuid(),
  type: z.enum(["message", "call", "sms", "system_action"]),
  actor: z.enum(["user", "ai_agent", "service_provider"]),
  section: z.enum(["left", "center", "right"]),
  content: z.string().min(1),
  timing: z.object({
    delay: z.number().min(0),
    duration: z.number().min(0),
  }),
  animation: z
    .object({
      type: z.enum(["typing", "appear", "call_ring", "thinking"]),
      easing: z.string().default("linear"),
    })
    .optional(),
});

const ScenarioSchema = z.object({
  id: z.string(),
  title: z.string(),
  phase: z.enum(["A2H", "LiteAgent", "A2A"]),
  description: z.string(),
  steps: z.array(ScenarioStepSchema).min(1),
});
```

### 5. 기술적 제약사항 및 성능 고려사항 (✅ 신규 추가)

**녹화 중 애니메이션 성능 최적화:**

- **메모리 사용량 제한**: 5분 연속 녹화 시 최대 2GB RAM 사용 제한
- **프레임 스케줄링**: `requestAnimationFrame` 기반 60fps → 30fps 다운샘플링
- **3섹션 동기화 최적화**: 중앙 섹션을 기준으로 좌우 섹션 애니메이션 동기화

**브라우저별 특화 최적화:**

- **Chrome/Edge**: Hardware acceleration 최적화, VP9 코덱 대안 지원
- **Safari**: WebKit 특화 transform 최적화, iOS Safari 터치 이벤트 고려
- **Firefox**: Gecko 엔진 특화 렌더링 최적화

**실시간 성능 모니터링:**

```typescript
const performanceMonitor = {
  fps: 0,
  memoryUsage: 0,
  animationCount: 0,
  checkPerformance: () => {
    if (performance.memory?.usedJSHeapSize > 2000000000) {
      // 2GB
      console.warn("Memory usage high, reducing animation complexity");
    }
  },
};
```

## 기술 스택 검증 결과 요약

### ✅ 검증 완료된 호환성

1. **Vite 7.1.2 + TypeScript 5.8.3**: 완벽 호환성 확인
2. **Framer Motion 12.23.12**: 복잡한 레이아웃 애니메이션 지원 검증
3. **Zustand 5.0.8**: 3섹션 상태 동기화 최적화 패턴 확인
4. **MediaRecorder API**: 모든 타겟 브라우저에서 H.264 30fps 지원 확인
5. **CSS Grid + aspect-ratio**: 16:9 반응형 레이아웃 네이티브 지원

### 🚀 성능 최적화 전략

1. **애니메이션 레이어 분리**: Layout, Transform, Opacity 애니메이션 독립 실행
2. **Optimized Appear**: SSR과 CSR 간 seamless 애니메이션 handoff
3. **메모리 관리**: 장시간 녹화를 위한 자동 메모리 정리
4. **3섹션 동기화**: 중앙 AI Agent를 기준으로 한 효율적인 상태 전파

## 변경 이후의 상태 / 해결 판정 기준

### 완료 기준

- [ ] 모든 8개 시나리오가 애니메이션으로 실행 가능
- [ ] 실시간 시나리오 편집 및 즉시 재생 기능
- [ ] 30fps H.264 MP4 녹화 및 다운로드 기능
- [ ] White/Black 테마 토글 완벽 동작
- [ ] 16:9 화면 비율 고정 및 반응형 대응
- [ ] 모든 주요 브라우저에서 정상 동작

### 성능 기준

- [ ] 시나리오 로딩 시간 < 500ms
- [ ] 애니메이션 프레임 드롭 없이 실행
- [ ] 녹화 중 UI 반응성 유지

## 수정이 필요한 코드 및 수정부분

### 1. 프로젝트 구조 재정의

```typescript
// src/types/index.ts - 새로 생성
interface Scenario {
  id: string;
  title: string;
  phase: "A2H" | "LiteAgent" | "A2A";
  steps: ScenarioStep[];
}

interface ScenarioStep {
  id: string;
  type: "message" | "call" | "sms" | "system_action";
  actor: string;
  content: string;
  timing: {
    delay: number;
    duration: number;
  };
  animation?: AnimationConfig;
}
```

### 2. 메인 애플리케이션 구조

```typescript
// src/App.tsx - 수정 필요
import { DemoView } from './components/DemoView';
import { ControlHeader } from './components/ControlHeader';
import { useTheme } from './hooks/useTheme';

function App() {
  const { theme, toggleTheme } = useTheme();

  return (
    <div className={`app ${theme}`}>
      <ControlHeader onThemeToggle={toggleTheme} />
      <DemoView />
    </div>
  );
}
```

### 3. 3-섹션 DemoView 구조

```typescript
// src/components/DemoView/index.tsx - 새로 생성
import { LeftSection } from './LeftSection';   // 사용자 폰 화면
import { CenterSection } from './CenterSection'; // AI Agent
import { RightSection } from './RightSection'; // 서비스제공자 폰 화면

function DemoView() {
  return (
    <div className="demo-view" style={{ aspectRatio: '16/9' }}>
      <div className="horizontal-sections">
        <LeftSection />   {/* 사용자 <-> AI Agent */}
        <CenterSection /> {/* AI Agent (Robot Icon, Progress) */}
        <RightSection />  {/* AI Agent <-> 서비스 공급자 */}
      </div>
    </div>
  );
}
```

### 4. 상태 관리 스토어

```typescript
// src/stores/scenarioStore.ts - 새로 생성
import { create } from "zustand";

interface ScenarioStore {
  currentScenario: Scenario | null;
  isPlaying: boolean;
  isRecording: boolean;
  currentStep: number;

  // 3-섹션 상태 관리
  leftSectionState: PhoneState;
  centerSectionState: AgentState;
  rightSectionState: PhoneState;

  loadScenario: (scenario: Scenario) => void;
  playScenario: () => void;
  pauseScenario: () => void;
  startRecording: () => void;
  stopRecording: () => void;

  // 섹션별 상태 업데이트
  updateLeftSection: (state: Partial<PhoneState>) => void;
  updateCenterSection: (state: Partial<AgentState>) => void;
  updateRightSection: (state: Partial<PhoneState>) => void;
}

interface PhoneState {
  messages: Message[];
  isTyping: boolean;
  currentInputText: string;
  callState: "idle" | "ringing" | "connected" | "ended";
  signalStrength: number;
  batteryLevel: number;
}

interface AgentState {
  isThinking: boolean;
  currentProcess: string;
  progressPercent: number;
  connectionLeft: boolean;
  connectionRight: boolean;
}
```

## 재사용 가능한 연관 코드

### 핵심 컴포넌트 구조

```text
src/
├── components/
│   ├── DemoView/
│   │   ├── index.tsx
│   │   ├── LeftSection/
│   │   │   ├── index.tsx           # 사용자 폰 화면
│   │   │   ├── PhoneFrame.tsx      # iPhone 베젤 UI
│   │   │   ├── MessageBubble.tsx   # WhatsApp 스타일 메시지
│   │   │   └── InputBox.tsx        # 메시지 입력 박스
│   │   ├── CenterSection/
│   │   │   ├── index.tsx           # AI Agent 중앙 섹션
│   │   │   ├── AgentRobot.tsx      # 로봇 아이콘
│   │   │   ├── ProgressCircle.tsx  # 처리 상태 원형 진행바
│   │   │   └── ConnectionLines.tsx # 좌우 연결선 애니메이션
│   │   └── RightSection/
│   │       ├── index.tsx           # 서비스제공자 폰 화면
│   │       ├── PhoneFrame.tsx      # iPhone 베젤 UI (재사용)
│   │       ├── MessageBubble.tsx   # 메시지 버블 (재사용)
│   │       └── InputBox.tsx        # 입력 박스 (재사용)
│   ├── ControlHeader/
│   │   ├── index.tsx
│   │   ├── ScenarioEditor.tsx      # JSON/PlantUML 편집기
│   │   ├── RecordingControls.tsx   # 녹화 컨트롤
│   │   └── ThemeToggle.tsx         # 테마 스위치
│   └── shared/
│       ├── AnimatedText.tsx        # 타이핑 애니메이션
│       ├── LoadingSpinner.tsx      # 로딩 인디케이터
│       └── StatusBar.tsx           # 폰 상단 상태바 (공통)
├── hooks/
│   ├── useScenarioPlayer.ts        # 시나리오 재생 로직
│   ├── useRecorder.ts              # MediaRecorder 관리
│   ├── useTheme.ts                 # 테마 관리
│   └── useSectionSync.ts           # 3섹션 동기화 관리
├── utils/
│   ├── scenarioParser.ts           # JSON 시나리오 파싱
│   ├── animationSequencer.ts       # 애니메이션 시퀀싱
│   ├── recordingUtils.ts           # 녹화 유틸리티
│   └── sectionLayoutUtils.ts       # 섹션 레이아웃 계산
└── data/
    └── scenarios/
        ├── phase1_scenarios.json
        ├── phase2_scenarios.json
        └── phase3_scenarios.json
```

### 애니메이션 전략

#### 3섹션 동기화 애니메이션

- **메시지 플로우**: 좌측(사용자) → 중앙(AI) → 우측(서비스제공자)으로 흐르는 시각적 연결
- **연결선 애니메이션**: 중앙 AI에서 좌우로 뻗어나가는 데이터 플로우 표현
- **동시 상태 변화**: 세 섹션의 상태가 연동되어 변화하는 시퀀스

#### 메시지 시스템 (좌우 섹션 공통)

- **타이핑 애니메이션**: 실제 타이핑 속도를 모방한 글자별 나타나기
- **메시지 버블**: 스케일업과 함께 bounce 효과로 등장
- **읽음 처리**: 체크 마크 색상 변화 애니메이션
- **섹션 간 메시지 전달**: 메시지가 중앙을 거쳐 전달되는 시각적 효과

#### AI 에이전트 상태 (중앙 섹션)

- **사고 중**: 점 3개가 순차적으로 bounce 하는 애니메이션
- **통화 중**: 전화 아이콘 주변에 펄스 링 효과
- **처리 중**: 원형 진행바와 함께 연결선 활성화 애니메이션
- **에이전트 간 통신**: A2A 단계에서 다중 에이전트 연결 표시

#### 화면 전환

- **시나리오 단계**: 스무스한 상태 전환
- **테마 변경**: 색상 값들의 부드러운 전환
- **섹션 포커스**: 활성 섹션 강조 및 비활성 섹션 흐림 효과

### 주요 훅 인터페이스

```typescript
// src/hooks/useScenarioPlayer.ts
export function useScenarioPlayer() {
  return {
    currentStep: number;
    isPlaying: boolean;
    progress: number;
    play: () => void;
    pause: () => void;
    reset: () => void;
    jumpToStep: (step: number) => void;
  };
}

// src/hooks/useRecorder.ts
export function useRecorder(targetElementId: string) {
  return {
    isRecording: boolean;
    startRecording: () => Promise<void>;
    stopRecording: () => Promise<Blob>;
    downloadRecording: (blob: Blob) => void;
  };
}
```

## Test Code 추가 및 수정 필요 부분

### 1. 컴포넌트 테스트

```typescript
// src/components/__tests__/PhoneFrame.test.tsx
import { render, screen } from '@testing-library/react';
import { PhoneFrame } from '../DemoView/PhoneFrame';

describe('PhoneFrame', () => {
  it('renders iPhone-style bezel correctly', () => {
    render(<PhoneFrame />);
    expect(screen.getByTestId('phone-bezel')).toBeInTheDocument();
  });

  it('maintains 16:9 aspect ratio', () => {
    const { container } = render(<PhoneFrame />);
    const demoArea = container.querySelector('[data-testid="demo-area"]');
    // Aspect ratio validation logic
  });
});
```

### 2. 시나리오 플레이어 테스트

```typescript
// src/hooks/__tests__/useScenarioPlayer.test.ts
import { renderHook, act } from "@testing-library/react";
import { useScenarioPlayer } from "../useScenarioPlayer";

describe("useScenarioPlayer", () => {
  it("plays scenario steps in sequence", async () => {
    const { result } = renderHook(() => useScenarioPlayer());

    act(() => {
      result.current.loadScenario(mockScenario);
      result.current.play();
    });

    expect(result.current.isPlaying).toBe(true);
  });
});
```

### 3. E2E 테스트 시나리오

```typescript
// e2e/recording.spec.ts
import { test, expect } from "@playwright/test";

test("complete scenario recording workflow", async ({ page }) => {
  await page.goto("/");

  // Load scenario
  await page.click('[data-testid="load-scenario-btn"]');
  await page.selectOption(
    '[data-testid="scenario-select"]',
    "phase1-restaurant",
  );

  // Start recording
  await page.click('[data-testid="record-btn"]');

  // Play scenario
  await page.click('[data-testid="play-btn"]');

  // Wait for completion
  await page.waitForSelector('[data-testid="scenario-complete"]');

  // Stop recording and download
  await page.click('[data-testid="stop-record-btn"]');

  // Verify download
  const downloadPromise = page.waitForEvent("download");
  await page.click('[data-testid="download-btn"]');
  const download = await downloadPromise;

  expect(download.suggestedFilename()).toMatch(/.*\.mp4$/);
});
```

### 4. 통합 테스트 우선순위

1. **시나리오 로딩 및 파싱** - 모든 8개 시나리오 정상 로드 검증
2. **애니메이션 시퀀싱** - 타이밍과 순서 정확성 검증
3. **녹화 기능** - 다양한 브라우저에서 H.264 MP4 생성 검증
4. **반응형 레이아웃** - 다양한 해상도에서 16:9 비율 유지 검증
5. **성능 테스트** - 장시간 시나리오 실행 시 메모리 누수 방지

## 구현 순서 및 마일스톤

### Phase 1: 기반 구조 (1-2일)

- [ ] TypeScript 타입 정의 (PhoneState, AgentState, Scenario)
- [ ] Zustand 스토어 구조 (3섹션 상태 관리)
- [ ] DemoView 기본 레이아웃 (3섹션 구조)
- [ ] 16:9 AspectRatio 유지 로직

### Phase 2: 3섹션 UI 컴포넌트 (3-4일)

- [ ] LeftSection (사용자 폰) 컴포넌트
- [ ] CenterSection (AI Agent) 컴포넌트
- [ ] RightSection (서비스제공자 폰) 컴포넌트
- [ ] PhoneFrame 공통 컴포넌트 (재사용)
- [ ] MessageBubble 시스템 (좌우 섹션)
- [ ] ConnectionLines 애니메이션 (중앙 섹션)
- [ ] ControlHeader 기본 구조

### Phase 3: 동기화 애니메이션 엔진 (4-5일)

- [ ] 3섹션 동기화 시나리오 파서
- [ ] 섹션 간 메시지 플로우 애니메이션
- [ ] AI Agent 상태 변화 시퀀싱
- [ ] Framer Motion 타이밍 제어
- [ ] useSectionSync 훅 구현

### Phase 4: 녹화 및 최적화 (2-3일)

- [ ] MediaRecorder 통합 (DemoView 영역만)
- [ ] 3섹션 동시 애니메이션 성능 최적화
- [ ] 브라우저 호환성 검증

## 성공 지표

### 1. 기능적 완성도

- [ ] 모든 8개 시나리오가 에러 없이 실행 (JSON 스키마 검증 포함)
- [ ] 3섹션 동기화 애니메이션 완벽 구현
- [ ] PlantUML ↔ JSON 양방향 변환 기능

### 2. 성능 및 품질 지표

- [ ] **30fps 안정성**: 5분 연속 녹화에서 프레임 드롭 < 1%
- [ ] **메모리 효율성**: 최대 메모리 사용량 < 2GB
- [ ] **애니메이션 품질**: 3섹션 간 동기화 지연 < 16ms (60fps 기준)
- [ ] **녹화 품질**: H.264 1080p 30fps MP4 생성 검증

### 3. 사용자 경험 지표

- [ ] **로딩 성능**: 시나리오 로딩 시간 < 500ms
- [ ] **반응성**: UI 인터랙션 지연 < 100ms (녹화 중 포함)
- [ ] **접근성**: 키보드 네비게이션 및 스크린 리더 지원
- [ ] **직관성**: 비개발자 테스터 5명 중 4명 이상 도구 사용 성공

### 4. 브라우저 호환성 지표

- [ ] **Chrome 100+**: 모든 기능 완벽 동작
- [ ] **Safari 15+**: iOS/macOS 포함 완전 호환
- [ ] **Firefox 100+**: 녹화 및 애니메이션 정상 동작
- [ ] **Edge 100+**: Chromium 기반 최적화

### 5. 기술적 안정성 지표

- [ ] **에러 복구**: 애니메이션 중단 시 자동 복구 메커니즘
- [ ] **상태 일관성**: 3섹션 상태 불일치 자동 감지 및 수정
- [ ] **메모리 누수 방지**: 5분+ 연속 실행 시 메모리 증가율 < 5%
- [ ] **TypeScript 엄격성**: strict 모드에서 0개 타입 에러

---

## 구현 전 최종 체크리스트

### 🔧 개발 환경 준비

- [x] **기술 스택 호환성**: Vite + TypeScript + Framer Motion + Zustand 검증 완료
- [x] **브라우저 테스트**: Chrome, Safari, Firefox에서 MediaRecorder API 동작 확인
- [x] **성능 벤치마크**: 복잡한 3섹션 애니메이션 성능 기준선 설정

### 📋 핵심 구현 요소

- [x] **아키텍처 설계**: 3섹션 동기화 상태 관리 패턴 정의
- [x] **데이터 구조**: Zod 기반 시나리오 스키마 검증 시스템
- [x] **애니메이션 전략**: Layout + Transform 분리 최적화 방법
- [x] **반응형 레이아웃**: CSS Grid + aspect-ratio 16:9 구현 방법

### 🎯 실행 준비도

- [ ] **컴포넌트 스캐폴딩**: 3섹션 구조 기본 틀 생성 필요
- [ ] **타입 정의**: PhoneState, AgentState, Scenario 인터페이스 구현 필요
- [ ] **시나리오 데이터**: 8개 시나리오 JSON 파일 작성 필요
- [ ] **성능 모니터링**: 실시간 FPS/메모리 추적 유틸리티 필요

### ⚡ 성능 최적화 준비

- [x] **Framer Motion 최적화**: Optimized Appear + Layout 분리 패턴 확인
- [x] **메모리 관리**: 장시간 녹화를 위한 자동 정리 전략 수립
- [x] **브라우저 특화**: Chrome/Safari/Firefox 각각의 최적화 포인트 파악

_작성일: 2025-09-13 14:30_  
_작성자: AI Development Assistant_  
_최종 검토: 기술적 검증 완료, 구현 준비 완료_
