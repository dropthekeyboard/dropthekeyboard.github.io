# ScrollControls Scroll-in-Scroll 이슈 해결 리팩터링 계획

**작성일**: 2025-09-18 05:02  
**작성자**: GitHub Copilot  
**목적**: ScenarioSectionContent에서 발생하는 scroll-in-scroll 충돌 문제 해결

---

## 작업의 목적

ScrollControls 컴포넌트에서 DemoView 내부의 MessageScreen auto scroll과 외부 ScrollTrigger 간의 충돌로 인해 발생하는 스크롤 동작 오류를 해결하여, 사용자가 시나리오 섹션에서 원활한 스크롤 경험을 할 수 있도록 개선한다.

## 현재의 상태 / 문제점

### 문제 상황

- **위치**: `src/components/Test/index.tsx`의 `ScenarioSectionContent`
- **증상**: 스크롤 다운 후 스크롤 업 시 예상과 다른 동작 발생
- **원인**: DemoView → MessageScreen의 auto scroll이 ScrollControls의 wheel 이벤트와 충돌

### 현재 코드 분석

```typescript
// ScrollControls.tsx - 현재 문제가 되는 부분
const handleScroll = (event: WheelEvent) => {
  const deltaY = event.deltaY;
  if (isNaN(deltaY)) {
    console.warn('ScrollControls: Received NaN deltaY, skipping');
    return;
  }
  // 모든 wheel 이벤트를 무차별적으로 처리
  accumulatedScroll.current += deltaY;
  // ...
};
```

### 근본 문제

1. **스크롤 소스 구분 없음**: 사용자 스크롤과 auto scroll 구분 불가
2. **이벤트 타겟 무시**: 내부 스크롤 영역과 외부 스크롤 영역 구분 없음
3. **컨텍스트 인식 부족**: pinning 상태와 스크롤 이벤트 간의 부적절한 연결

## 추가 분석 과제

### 1. DemoView 구조 상세 분석

- `src/components/DemoView/index.tsx`의 실제 DOM 구조 확인
- 각 Section(Customer, Agent, Server)별 스크롤 영역 파악
- MessageScreen의 auto scroll 구현 방식 및 이벤트 패턴 분석

### 2. ScrollTrigger와의 상호작용 분석

- GSAP ScrollTrigger와 wheel 이벤트의 충돌 지점 식별
- pinning 상태 변화 시점과 스크롤 이벤트 발생 타이밍 분석

### 3. 사용자 경험 패턴 분석

- 정상적인 사용자 스크롤 패턴 vs auto scroll 패턴 특성 파악
- 스크롤 속도, 빈도, deltaY 값의 차이점 분석

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **기능적 개선**
   - 시나리오 섹션에서 스크롤 다운 → 업 시 정상 동작
   - 내부 MessageScreen auto scroll이 외부 ScrollControls에 영향 주지 않음
   - 사용자 스크롤과 auto scroll의 명확한 구분 처리

2. **성능 기준**
   - 스크롤 반응성 저하 없음 (100ms 이내 반응)
   - 불필요한 이벤트 처리 최소화

3. **안정성 기준**
   - 기존 pinning 동작에 부작용 없음
   - 다른 섹션(slide, scenario-intro)의 스크롤 동작 정상 유지

### 테스트 케이스

- [ ] 시나리오 섹션 진입 후 스크롤 다운 → 스크롤 업 정상 동작
- [ ] MessageScreen 내부 스크롤이 ScrollControls에 영향 주지 않음
- [ ] 빠른 연속 스크롤 시 정상 처리
- [ ] auto scroll 발생 중 사용자 스크롤 간섭 없음

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ScrollControls.tsx - 메인 수정

**파일**: `src/components/ControlHeader/ScrollControls.tsx`

```typescript
// 현재 코드 (문제 부분)
export function ScrollControls({
  enabled = true,
  threshold = 30,
  pinnedState,
}: ScrollControlsProps) {
  // 기존 구현...
}

// 수정 코드
interface ScrollControlsProps {
  enabled?: boolean;
  threshold?: number;
  pinnedState?: SectionPinningState;
  excludeSelectors?: string[];
  autoScrollThreshold?: number;
}

export function ScrollControls({
  enabled = true,
  threshold = 30,
  pinnedState,
  excludeSelectors = ['.message-container', '.demo-view-content'],
  autoScrollThreshold = 50,
}: ScrollControlsProps) {
  // 새로운 스크롤 필터링 로직 구현
  const isInternalScrollTarget = (target: EventTarget | null): boolean => {
    if (!target || !(target instanceof Element)) return false;
    return excludeSelectors.some((selector) => {
      try {
        return target.closest(selector) !== null;
      } catch {
        return false;
      }
    });
  };

  const isLikelyAutoScroll = (deltaY: number): boolean => {
    // auto scroll 감지 로직
    return Math.abs(deltaY) > autoScrollThreshold;
  };

  const handleScroll = (event: WheelEvent) => {
    // 내부 스크롤 타겟 필터링
    if (isInternalScrollTarget(event.target)) {
      return;
    }

    // auto scroll 필터링
    if (isLikelyAutoScroll(event.deltaY)) {
      return;
    }

    // 기존 스크롤 처리 로직
  };
}
```

### 2. ScenarioSectionContent - ScrollControls 설정 개선

**파일**: `src/components/Test/index.tsx`

```typescript
// 현재 코드
<ScrollControls
  enabled={true}
  threshold={15}
  pinnedState={state}
/>

// 수정 코드
<ScrollControls
  enabled={true}
  threshold={30}
  pinnedState={state}
  excludeSelectors={[
    '.message-container',
    '.demo-view-content',
    '.demo-sections-container'
  ]}
  autoScrollThreshold={50}
/>
```

### 3. DemoView - 스크롤 격리 (선택적 적용)

**파일**: `src/components/DemoView/index.tsx`

```typescript
// 추가 격리가 필요한 경우
export function DemoView() {
  return (
    <div
      className="demo-view-content w-full h-full"
      onWheel={(e) => {
        // 필요시 이벤트 전파 제어
        if (shouldIsolateScroll(e)) {
          e.stopPropagation();
        }
      }}
    >
      {/* 기존 내용 */}
    </div>
  );
}
```

## 재사용 가능한 연관 코드

### 관련 파일 및 인터페이스

1. **`src/contexts/pinning.tsx`**
   - `SectionPinningState` interface
   - `useSectionPinning` hook
   - 섹션별 상태 관리 로직

2. **`src/components/shared/AnimatedSlide.tsx`**
   - 유사한 sectionIndex 기반 상태 관리 패턴
   - pinning 상태 활용 예시

3. **`src/hooks/useScenario.ts`**
   - `progressNext`, `revertToPrev` 함수들
   - 시나리오 진행 상태 관리

### 재사용 가능한 패턴

```typescript
// 스크롤 이벤트 필터링 유틸리티
export const createScrollEventFilter = (
  excludeSelectors: string[] = [],
  autoScrollThreshold: number = 50
) => {
  return {
    isInternalScrollTarget: (target: EventTarget | null): boolean => {
      // 재사용 가능한 타겟 필터링 로직
    },
    isLikelyAutoScroll: (deltaY: number): boolean => {
      // 재사용 가능한 auto scroll 감지 로직
    },
  };
};
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. 단위 테스트 추가

**파일**: `src/components/ControlHeader/__tests__/ScrollControls.test.tsx`

```typescript
describe('ScrollControls', () => {
  test('should ignore scroll events from internal elements', () => {
    // 내부 스크롤 요소에서 발생한 이벤트 무시 테스트
  });

  test('should detect and ignore auto scroll patterns', () => {
    // auto scroll 패턴 감지 및 무시 테스트
  });

  test('should process normal user scroll events', () => {
    // 정상적인 사용자 스크롤 처리 테스트
  });
});
```

### 2. 통합 테스트 시나리오

**파일**: `src/components/Test/__tests__/integration.test.tsx`

```typescript
describe('ScenarioSectionContent Integration', () => {
  test('should handle scroll down and up correctly', () => {
    // 스크롤 다운 → 업 시나리오 통합 테스트
  });

  test('should isolate internal MessageScreen scrolls', () => {
    // MessageScreen 스크롤 격리 테스트
  });
});
```

### 3. E2E 테스트 가이드

- Playwright/Cypress를 활용한 실제 스크롤 동작 테스트
- 시나리오 섹션에서의 사용자 스크롤 시뮬레이션
- auto scroll과 사용자 스크롤의 상호작용 테스트

---

## 주의사항

- 기존 pinning 동작을 변경하지 않고 스크롤 이벤트 처리만 개선
- 성능 저하를 방지하기 위해 과도한 이벤트 필터링 지양
- 브라우저별 wheel 이벤트 차이점 고려하여 범용성 확보
- 모바일 터치 스크롤과의 호환성 검토 필요
