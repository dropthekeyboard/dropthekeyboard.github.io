# Refactoring Plan: ScrollyTelling용 Progress Tracker 컴포넌트 추가

## 작업의 목적

Test 컴포넌트의 ScrollyTelling 인터랙션에서 사용자가 현재 스크롤 진행 상황과 남은 섹션을 직관적으로 파악할 수 있도록 하는 Progress Tracker UI 컴포넌트를 추가한다. 이를 통해 사용자 경험을 개선하고, 긴 ScrollyTelling 콘텐츠에서 현재 위치와 전체 구조를 명확히 인지할 수 있도록 한다.

## 현재의 상태 / 문제점

### 현재 Test 컴포넌트 구조

- **16개 슬라이드** + **다중 시나리오 섹션**으로 구성된 긴 ScrollyTelling 콘텐츠
- **GSAP ScrollTrigger**를 활용한 섹션별 pinning 기능
- **PinningProvider/usePinning**을 통한 섹션 상태 관리
- **SectionData 인터페이스**로 슬라이드, 시나리오 구분 및 pinning 설정

### 식별된 문제점

1. **진행률 가시성 부족**: 사용자가 전체 콘텐츠 중 현재 위치를 파악하기 어려움
2. **네비게이션 기능 부재**: 특정 섹션으로 직접 이동할 수 있는 수단 없음
3. **섹션 구조 인지 어려움**: 슬라이드와 시나리오의 구분, 남은 섹션 수 파악 불가
4. **긴 콘텐츠의 UX 저하**: 스크롤 진행 상황에 대한 피드백 부족

## 관련 코드의 통합 구조 (Birdeye View)

```
Test Component Architecture
├── GSAPPinningDemo (Main Container)
│   ├── PinningProvider (전역 상태 관리)
│   └── GSAPPinningDemoContent
│       ├── slideComponents[] (16개 슬라이드)
│       ├── scenarios[] (시나리오 데이터)
│       ├── sections[] (통합 섹션 배열)
│       ├── sectionRefs[] (DOM 참조)
│       └── ScrollTrigger 설정
│
└── 연관 Context & Hooks
    ├── usePinning() - 섹션별 상태 관리
    ├── useSectionPinning() - 개별 섹션 상태
    ├── useScenario() - 시나리오 진행 관리
    └── useScrollProgress() - 스크롤 기반 진행률 (기존)
```

### 기존 Progress Tracking 관련 인프라

- `src/components/StorytellingPage/ScrollProgressIndicator.tsx` - 세로 진행률 바 구현체
- `src/hooks/useScrollProgress.ts` - 스크롤 기반 진행률 추적
- `src/types/storytelling.ts` - 진행률 관련 타입 정의
- `src/contexts/pinning.tsx` - 섹션별 pinning 상태 관리

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **시각적 진행률 표시**: 우측/좌측에 node-edge-node 형태의 진행률 트래커 배치
2. **섹션별 구분 표시**: 슬라이드와 시나리오 섹션을 다른 스타일로 구분
3. **현재 위치 강조**: 활성 섹션의 시각적 하이라이트 및 애니메이션
4. **클릭 네비게이션**: 버블 클릭 시 해당 섹션으로 smooth scroll 이동
5. **반응형 디자인**: 모바일에서는 숨김 처리 또는 최소화

### 판정 기준

- [ ] Progress Tracker가 스크롤 진행률에 실시간 반응
- [ ] 16개 슬라이드 + N개 시나리오 섹션 모두 표시
- [ ] 현재 활성 섹션이 명확히 구분됨
- [ ] 버블 클릭으로 섹션 간 이동 가능
- [ ] 기존 ScrollTrigger 로직과 충돌 없음

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ScrollProgressTracker 컴포넌트 생성

**파일**: `src/components/Test/ScrollProgressTracker.tsx` (신규)

```typescript
import React from 'react';
import { motion } from 'framer-motion';
import { cn } from '@/lib/utils';
import { useTheme } from '@/hooks/useTheme';

interface ProgressNode {
  id: string;
  type: 'slide' | 'scenario-intro' | 'scenario';
  title: string;
  isActive: boolean;
  isCompleted: boolean;
  index: number;
}

interface ScrollProgressTrackerProps {
  sections: ProgressNode[];
  onNodeClick: (index: number) => void;
  position?: 'left' | 'right';
  className?: string;
}

export function ScrollProgressTracker({
  sections,
  onNodeClick,
  position = 'right',
  className,
}: ScrollProgressTrackerProps) {
  const { isDark } = useTheme();

  return (
    <div
      className={cn(
        'fixed top-1/2 -translate-y-1/2 z-30',
        position === 'right' ? 'right-4' : 'left-4',
        'hidden lg:block', // 모바일에서 숨김
        className
      )}
    >
      {/* Progress Line */}
      <div className="relative">
        <div
          className={cn(
            'w-0.5 h-80 rounded-full',
            isDark ? 'bg-gray-700/60' : 'bg-gray-300/60'
          )}
        />

        {/* Nodes */}
        <div className="absolute inset-0 flex flex-col justify-between">
          {sections.map((section, index) => (
            <ProgressNodeComponent
              key={section.id}
              section={section}
              onClick={() => onNodeClick(index)}
              isDark={isDark}
            />
          ))}
        </div>
      </div>
    </div>
  );
}
```

### 2. Test 컴포넌트 통합 수정

**파일**: `src/components/Test/index.tsx` (수정 필요)

```typescript
// 기존 import에 추가
import { ScrollProgressTracker } from './ScrollProgressTracker';

// GSAPPinningDemoContent 함수 내부에 추가
function GSAPPinningDemoContent({ agentStyle = 'reasoning' }: GSAPPinningDemoProps) {
  // ... 기존 코드 ...

  // Progress Tracker를 위한 섹션 데이터 변환
  const progressNodes = useMemo(() => {
    return sections.map((section, index) => ({
      id: section.type === 'slide' ? `slide-${index}` : `${section.type}-${section.id}-${index}`,
      type: section.type,
      title: section.title,
      isActive: false, // 실제 로직에서 계산
      isCompleted: false, // 실제 로직에서 계산
      index,
    }));
  }, [sections]);

  // 섹션 네비게이션 핸들러
  const handleNodeClick = useCallback((sectionIndex: number) => {
    const targetSection = sectionRefs.current[sectionIndex];
    if (targetSection) {
      targetSection.scrollIntoView({
        behavior: 'smooth',
        block: 'start',
      });
    }
  }, []);

  return (
    <div className="w-full relative">
      {/* Progress Tracker 추가 */}
      <ScrollProgressTracker
        sections={progressNodes}
        onNodeClick={handleNodeClick}
        position="right"
      />

      {/* 기존 섹션 렌더링 로직 */}
      {sections.map((section, index) => {
        // ... 기존 코드 유지 ...
      })}
    </div>
  );
}
```

### 3. 진행률 추적 로직 추가

**파일**: `src/components/Test/hooks/useTestScrollProgress.ts` (신규)

```typescript
import { useState, useEffect, useCallback } from 'react';
import { usePinning } from '@/contexts/pinning';

interface UseTestScrollProgressReturn {
  currentSectionIndex: number;
  scrollProgress: number;
  updateProgressNodes: (nodes: ProgressNode[]) => ProgressNode[];
}

export function useTestScrollProgress(
  sectionRefs: React.MutableRefObject<(HTMLDivElement | null)[]>,
  sectionsLength: number
): UseTestScrollProgressReturn {
  const [currentSectionIndex, setCurrentSectionIndex] = useState(0);
  const [scrollProgress, setScrollProgress] = useState(0);
  const { sectionsState } = usePinning();

  // IntersectionObserver로 현재 활성 섹션 추적
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const index = sectionRefs.current.findIndex(
              (ref) => ref === entry.target
            );
            if (index !== -1) {
              setCurrentSectionIndex(index);
            }
          }
        });
      },
      { threshold: 0.5 }
    );

    sectionRefs.current.forEach((ref) => {
      if (ref) observer.observe(ref);
    });

    return () => observer.disconnect();
  }, [sectionRefs, sectionsLength]);

  return {
    currentSectionIndex,
    scrollProgress,
    updateProgressNodes: useCallback(
      (nodes) => {
        return nodes.map((node, index) => ({
          ...node,
          isActive: index === currentSectionIndex,
          isCompleted: index < currentSectionIndex,
        }));
      },
      [currentSectionIndex]
    ),
  };
}
```

## 재사용 가능한 연관 코드

### 기존 컴포넌트 재활용

1. **`src/components/StorytellingPage/ScrollProgressIndicator.tsx`**
   - 세로 진행률 바 UI 패턴 참조
   - 애니메이션 및 스타일링 로직 재활용

2. **`src/hooks/useScrollProgress.ts`**
   - 스크롤 이벤트 핸들링 패턴
   - 진행률 계산 로직 참조

3. **`src/contexts/pinning.tsx`**
   - `SectionPinningState` 인터페이스
   - `useSectionPinning` hook 활용

### 재사용 가능한 타입 정의

```typescript
// src/types/test.ts (신규)
export interface TestSectionNode extends SectionData {
  isActive: boolean;
  isCompleted: boolean;
  progressPercentage: number;
}

export interface TestScrollProgressState {
  currentSection: number;
  totalSections: number;
  overallProgress: number;
  sectionProgress: number;
}
```

### 공통 유틸리티 함수

```typescript
// src/utils/scrollUtils.ts (신규 또는 기존 확장)
export const smoothScrollToSection = (
  element: HTMLElement,
  options?: ScrollIntoViewOptions
) => {
  element.scrollIntoView({
    behavior: 'smooth',
    block: 'start',
    ...options,
  });
};

export const calculateSectionProgress = (
  currentIndex: number,
  totalSections: number
): number => {
  return totalSections > 0 ? currentIndex / (totalSections - 1) : 0;
};
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 추가

1. **ScrollProgressTracker 컴포넌트 테스트**

   ```typescript
   // src/components/Test/__tests__/ScrollProgressTracker.test.tsx
   describe('ScrollProgressTracker', () => {
     it('should render progress nodes correctly', () => {
       // 노드 렌더링 테스트
     });

     it('should handle node click events', () => {
       // 클릭 이벤트 핸들링 테스트
     });

     it('should show active and completed states', () => {
       // 상태 표시 테스트
     });
   });
   ```

2. **useTestScrollProgress 훅 테스트**
   ```typescript
   // src/components/Test/__tests__/useTestScrollProgress.test.ts
   describe('useTestScrollProgress', () => {
     it('should track current section index', () => {
       // 섹션 추적 테스트
     });

     it('should update progress nodes correctly', () => {
       // 진행률 노드 업데이트 테스트
     });
   });
   ```

### 통합 테스트 가이드

1. **ScrollTrigger와의 호환성 테스트**
   - 기존 pinning 로직 영향 없음 확인
   - 성능 저하 없음 검증

2. **반응형 동작 테스트**
   - 모바일에서 숨김 처리 확인
   - 다양한 화면 크기에서 위치 정확성 검증

3. **접근성 테스트**
   - 키보드 네비게이션 지원
   - 스크린 리더 호환성

### 추가 분석 과제

1. **성능 최적화 분석**
   - IntersectionObserver vs Scroll Event 성능 비교
   - 대량 섹션 처리 시 렌더링 최적화 방안

2. **사용자 경험 개선 방안**
   - 진행률 표시 방식의 효과성 분석
   - 클릭 네비게이션 사용 패턴 조사

3. **확장성 고려사항**
   - 다른 ScrollyTelling 컴포넌트에서의 재사용 가능성
   - 커스터마이징 옵션 확장 방향성
