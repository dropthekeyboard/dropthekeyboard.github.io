# Refactoring Plan: Slide005 Bar Chart Animation not running in GSAPSlidesPage path

## 작업의 목적

- GSAPSlidesPage 경로에서 Slide005의 바 차트/실린더 애니메이션이 작동하지 않는 문제를 해결한다.
- Pinning 기반 애니메이션 트리거를 두 경로(Test 데모와 GSAPSlidesPage) 모두 일관되게 작동하도록 통합한다.

## 현재의 상태 / 문제점

- GSAPSlidesPage에서는 섹션을 GSAP의 ScrollTrigger로 핀/스크럽 처리만 하고, PinningContext를 갱신하지 않는다.
- Slide005는 내부 애니메이션 트리거로 PinningContext의 `isPinned`(useSectionPinning)를 참조한다.
- GSAPSlidesPage 경로에는 `PinningProvider`가 없고(또는 컨텍스트 갱신이 없음), `SlideGSAPSection`도 컨텍스트와 연동되지 않아 `isPinned`가 항상 false → width 0%, 카운트업 미시작.
- 추가로 `Slide005`의 `sectionIndex` 기본값이 0으로 고정되어 있어, 설령 Provider가 있어도 인덱스 불일치 가능.

## 관련 코드의 통합 구조 (Bird-eye View)

- components/Slide/GSAPSlidesPage.tsx: 각 슬라이드를 `SlideGSAPSection`으로 래핑해 ScrollTrigger 애니메이션/핀 제어. PinningContext 미사용.
- components/Slide/SlideGSAPSection.tsx: ScrollTrigger 생성 및 섹션 진입/핀 애니메이션 구성. 컨텍스트로 상태 업데이트 없음.
- contexts/pinning.tsx: Pinning 상태 전역 관리. `PinningProvider`, `usePinning`, `useSectionPinning` 제공.
- components/Test/index.tsx: `PinningProvider`로 감싸고, 섹션별 ScrollTrigger onToggle에서 `updateSectionState` 호출 → `isPinned` 등 갱신. 이 경로에서는 Slide005 애니메이션 정상 작동.
- components/Slide/Slide005.tsx: `useSectionPinning(sectionIndex)`의 `state.isPinned`를 사용하여 바 width, 실린더 카운트업 트리거.

## 변경 이후의 상태 / 해결 판정 기준

- GSAPSlidesPage 경로에서도 각 섹션의 핀 상태가 PinningContext로 반영되어 `Slide005`가 `isPinned === true`를 받을 수 있어야 한다.
- 최소 기준: Slide005의 바 차트 width가 스크롤로 섹션이 고정될 때 0% → 목표 너비로 애니메이션되고, 실린더 값이 카운트업 된다.
- 회귀 기준: Test 데모 경로(components/Test/index.tsx)의 기존 동작은 그대로 유지.

## 해결 옵션(트레이드오프 포함)

### 옵션 A: GSAPSlidesPage를 PinningContext와 연동 (권장)

- 상위에 `PinningProvider`를 추가.
- 각 `SlideGSAPSection`에 `sectionIndex`를 부여해 전달.
- `SlideGSAPSection`에서 ScrollTrigger onToggle 시 `updateSectionState(index, { isPinned, isEntering, isLeaving })`를 호출해 컨텍스트 갱신.
- 장점: 구조적 일관성. Slide 내부에서 컨텍스트 하나만 보면 됨. Test 경로와 동일 패턴.
- 단점: `SlideGSAPSection` API 변경, 인덱스 관리 필요.

코드 스니핏(개념 예시):

- SlideGSAPSection.tsx
  - props에 `sectionIndex?: number` 추가
  - `const { updateSectionState } = usePinning()` 사용 (컨텍스트 접근)
  - ScrollTrigger vars에 `onToggle` 추가하여 `updateSectionState(sectionIndex, { ... })`
- GSAPSlidesPage.tsx
  - 페이지를 `<PinningProvider>`로 감싸기
  - 각 섹션에 `sectionIndex` 부여(0..n-1)
  - Slide005에도 같은 인덱스를 prop으로 전달: `<Slide005 sectionIndex={index} />`

### 옵션 B: SlideGSAPSection이 자식에게 활성화 플래그 전달

- `SlideGSAPSection`이 내부 ScrollTrigger의 활성/핀 상태를 감지하여 render-prop 또는 context로 `isActive`(or isPinned) 전달.
- `Slide005`는 `useSectionPinning` 대신 부모로부터 받은 `isActive`로 애니메이션 트리거.
- 장점: PinningContext 의존 제거, 로컬 컴포넌트 트리에서 완결.
- 단점: 기존 Test 경로(`useSectionPinning` 사용)와 이원화. 공통성 저하.

코드 스니핏(개념 예시):

- SlideGSAPSection: children을 function-as-child로 허용 `(ctx) => JSX` 형태, ctx에 `{ isPinned }` 전달
- GSAPSlidesPage: `<SlideGSAPSection>{({isPinned}) => <Slide005 isActive={isPinned}/>}</SlideGSAPSection>`
- Slide005: prop `isActive` 사용, `useSectionPinning` 의존 제거 또는 fallback 로직 유지

### 옵션 C: Slide005가 자체 in-view/pin 상태를 감지

- Slide005에서 `ScrollTrigger.create({ trigger: self, start: 'top top', end: '+=<distance>', pin: false, onToggle: ... })`로 로컬 상태를 관리하거나, IntersectionObserver로 in-view를 감지하여 애니메이션 시작.
- 장점: 최소 침투 변경(상위/공용 코드 영향 적음).
- 단점: 이중 ScrollTrigger 생성으로 복잡성 증가 가능. Pinning 시점과 오차 가능. 재사용성 떨어짐.

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

- 옵션 A 기준(권장) 요약 스니핏:
  1. `SlideGSAPSection.tsx`
     - `import { usePinning } from '@/contexts/pinning'`
     - `export type SlideGSAPSectionProps`에 `sectionIndex?: number` 추가
     - `const { updateSectionState } = usePinning();`
     - ScrollTrigger Vars에 `onToggle: (self) => { if (sectionIndex!=null) updateSectionState(sectionIndex, { isPinned: self.isActive, isEntering: self.isActive && self.direction!==-1, isLeaving: !self.isActive && self.direction!==1 }); }`
     - dependencies에 `sectionIndex` 포함
  2. `GSAPSlidesPage.tsx`
     - 전체를 `<PinningProvider>`로 감싸기
     - 섹션 순서대로 `sectionIndex`를 각 `SlideGSAPSection`과 내부 슬라이드 컴포넌트에 전달: `<SlideGSAPSection sectionIndex={i}><Slide005 sectionIndex={i}/></SlideGSAPSection>`

- 보조 수정(권장): `Slide005.tsx`에서 `sectionIndex` 필수 prop로 전환 또는 부모에서 정확히 주입하도록 convention 확립. 또한 `duration-1200`과 같은 Tailwind 유틸이 테마에 없을 경우 `transition-[duration:1200ms]` 형태로 안전하게 지정 검토.

## 재사용 가능한 연관 코드

- `contexts/pinning.tsx`: 전역 핀 상태 인터페이스 및 Provider/Hook. 기존 Test 데모에서 검증됨.
- `components/Test/index.tsx`: ScrollTrigger → PinningContext 동기화 레퍼런스 구현(완료 동작 버전).
- `components/shared/CylinderBar.tsx`: `isActive` 플래그 기반 카운트업 로직.
- `components/shared/AnimatedSlide.tsx`: `useSectionPinning` 연계 예시.

## Test Code 추가/수정 가이드

- 단위 테스트(가능 범위):
  - `contexts/pinning.tsx`의 `updateSectionState`가 불변성 지키며 병합되는지 테스트.
  - `Slide005` 렌더 시 `isPinned=true`일 때 width 스타일과 `CylinderBar`의 `isActive` 전달이 맞는지 snapshot/assert.
- 통합/시각 테스트(수동 또는 Playwright 추천):
  - GSAPSlidesPage 경로에서 스크롤 시 Slide005 섹션 진입 후 pin 상태에서 막대가 0% → 목표 너비로 증가하는지 확인.
  - 실린더 값이 0 → target(예: 17.5, 2.7)로 카운트업 되는지.
  - 상하 스크롤 반복 시(once=false) 되감기/재재생 동작 여부 확인.
- 회귀 체크:
  - `components/Test/index.tsx` 기반 데모에서 모든 섹션 pinning/애니메이션 정상 동작.

## 해결 판정 기준(수행 완료 정의)

- GSAPSlidesPage에서 Slide005 바 차트와 실린더 애니메이션이 스크롤 pin 구간에서 정상 재생됨.
- 빠르게 위/아래 스크롤해도 상태 불일치 없이 `isPinned` 갱신됨(깜빡임/미동작 없음).
- Test 데모 경로의 기존 ScrollTrigger/Pinning 연동 기능에 회귀 없음.

## 추가 분석 과제

- `sectionIndex` 부여 전략을 공통 유틸로 추출(예: 상수 맵/배열로 중앙관리)하여 인덱스 mismatch 위험 제거.
- Tailwind v4에서 사용할 커스텀 transition-duration 유틸을 theme 확장으로 정의하거나, 임의 값 유틸(`transition-[duration:1200ms]`)로 일원화.
- `min-h-screenflex` 오타 수정 및 전반 레이아웃 클래스 정리(레이아웃에 의한 ScrollTrigger 시작점 일관성 확보 목적).
