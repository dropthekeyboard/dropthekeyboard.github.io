# Slide 컴포넌트 Pinning 상태 연동 리팩토링 계획

## 작업의 목적

Slide 컴포넌트들이 GSAP ScrollTrigger의 pinning 상태를 활용하여 동적 애니메이션을 실행할 수 있도록 시스템을 개선합니다. 특히 Slide004, Slide005와 같이 데이터 시각화가 포함된 슬라이드에서 pinning 진입 시 차트 애니메이션이 자동으로 실행되도록 구현합니다.

## 현재의 상태 / 문제점

### 1. Slide 컴포넌트 인터페이스 불일치

- Test 컴포넌트에서 Slide 컴포넌트들에게 `sectionIndex`를 전달하지 않음
- 각 Slide가 자신의 pinning 상태를 알 수 없는 구조
- 현재 코드: `{Component && <Component />}`

### 2. 타입 정의 부재

- 모든 Slide 컴포넌트가 사용할 공통 Props 타입이 정의되지 않음
- 타입 안전성 부족으로 런타임 에러 가능성 존재

### 3. 애니메이션 컴포넌트 미구현

- 데이터 시각화를 위한 재사용 가능한 애니메이션 컴포넌트 부재
- Slide004(수평 바 차트), Slide005(수직 바 차트)에서 pinning 기반 애니메이션 필요

### 4. pinning 상태 활용 부족

- 기존 pinning 시스템이 구축되어 있음에도 Slide 레벨에서 활용되지 않음
- `useSectionPinning` hook이 Scenario 섹션에서만 사용됨

## 추가 분석 과제

### 1. 애니메이션 성능 최적화

- 다수의 Slide에서 동시에 애니메이션이 실행될 때의 성능 영향도 분석
- `requestAnimationFrame` 기반 애니메이션의 메모리 사용량 모니터링

### 2. 반응형 차트 구현

- 다양한 화면 크기에서 차트 애니메이션의 적절한 동작 확인
- 모바일 환경에서의 애니메이션 최적화 방안 검토

### 3. 접근성 고려사항

- 애니메이션 비활성화 옵션 (`prefers-reduced-motion`) 지원 방안
- 스크린 리더 사용자를 위한 대체 콘텐츠 제공 방안

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **일관된 인터페이스**: 모든 Slide 컴포넌트가 `SlideProps` 타입을 준수
2. **동적 애니메이션**: Slide004, Slide005에서 pinning 진입 시 자동 애니메이션 실행
3. **재사용성**: 차트 애니메이션 컴포넌트가 다른 슬라이드에서도 활용 가능
4. **타입 안전성**: TypeScript 컴파일 에러 없이 모든 props 타입 검증
5. **성능**: 애니메이션 실행 시 60fps 유지, 메모리 누수 없음

### 테스트 시나리오

- Slide004 pinning 시 수평 바 차트가 0에서 실제 값까지 애니메이션
- Slide005 pinning 시 수직 바 차트가 동시에 애니메이션
- pinning 해제 시 애니메이션이 초기 상태로 복원
- 빠른 스크롤 시에도 애니메이션이 정상 동작

## 수정이 필요한 코드 및 수정부분

### 1. 타입 정의 추가

**파일**: `/src/types/slide.ts` (신규 생성)

```typescript
export interface SlideProps {
  sectionIndex: number;
}

export interface AnimationConfig {
  duration?: number;
  delay?: number;
  easing?: string;
}
```

### 2. Test 컴포넌트 수정

**파일**: `/src/components/Test/index.tsx`
**수정 대상**: Line 302-308

```typescript
// 현재
{Component && <Component />}

// 수정 후
{Component && <Component sectionIndex={index} />}
```

### 3. 애니메이션 Hook 추가

**파일**: `/src/hooks/useCountAnimation.ts` (신규 생성)

```typescript
import { useEffect, useState } from 'react';

export function useCountAnimation(
  targetValue: number,
  isActive: boolean,
  duration = 1200
) {
  const [currentValue, setCurrentValue] = useState(0);

  useEffect(() => {
    if (!isActive) {
      setCurrentValue(0);
      return;
    }

    let start: number | null = null;
    const animate = (timestamp: number) => {
      if (!start) start = timestamp;
      const progress = Math.min((timestamp - start) / duration, 1);
      setCurrentValue(Math.floor(progress * targetValue));

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };

    requestAnimationFrame(animate);
  }, [targetValue, isActive, duration]);

  return currentValue;
}
```

### 4. 애니메이션 컴포넌트 추가

**파일**: `/src/components/ui/animated-bar.tsx` (신규 생성)

```typescript
import { cn } from "@/lib/utils";
import { useCountAnimation } from "@/hooks/useCountAnimation";

interface AnimatedBarProps {
  value: number;
  maxValue: number;
  label: string;
  subLabel: string;
  isActive: boolean;
  className?: string;
}

export function AnimatedBar({
  value,
  maxValue,
  label,
  subLabel,
  isActive,
  className
}: AnimatedBarProps) {
  const animatedValue = useCountAnimation(value, isActive);
  const heightPercentage = Math.min((animatedValue / maxValue) * 100, 100);

  return (
    <div className={cn("flex flex-col items-center", className)}>
      <div className="relative flex flex-col items-center">
        <div
          className="w-20 bg-gradient-to-r from-blue-500 to-purple-500 rounded-t-lg absolute bottom-0 transition-all duration-100"
          style={{ height: `${heightPercentage * 2}px` }}
        />
        <div className="w-20 bg-muted rounded-lg border-2 border-border" style={{ height: '200px' }} />
        <span className="absolute -top-16 left-1/2 -translate-x-1/2 text-4xl font-bold text-foreground">
          {animatedValue}%
        </span>
      </div>
      <div className="mt-6 text-center space-y-2">
        <div className="text-sm text-muted-foreground">{subLabel}</div>
        <div className="font-bold text-foreground text-lg">{label}</div>
      </div>
    </div>
  );
}
```

**파일**: `/src/components/ui/animated-horizontal-bar.tsx` (신규 생성)

```typescript
import { cn } from "@/lib/utils";
import { useCountAnimation } from "@/hooks/useCountAnimation";

interface AnimatedHorizontalBarProps {
  value: number;
  maxValue: number;
  label: string;
  subLabel: string;
  unit?: string;
  isActive: boolean;
  className?: string;
}

export function AnimatedHorizontalBar({
  value,
  maxValue,
  label,
  subLabel,
  unit = "",
  isActive,
  className
}: AnimatedHorizontalBarProps) {
  const animatedValue = useCountAnimation(value, isActive);
  const widthPercentage = Math.min((animatedValue / maxValue) * 100, 100);

  const formatValue = (val: number) => {
    if (val >= 1000000) {
      return `${(val / 1000000).toFixed(1)}M`;
    }
    if (val >= 1000) {
      return `${(val / 1000).toFixed(1)}K`;
    }
    return val.toString();
  };

  return (
    <div className={cn("space-y-4", className)}>
      <div className="flex items-center justify-between">
        <div className="space-y-2">
          <p className="text-lg font-semibold text-foreground">{label}</p>
          <p className="text-base text-muted-foreground">{subLabel}</p>
        </div>
        <div className="text-right">
          <p className="text-3xl font-bold text-foreground">
            {formatValue(animatedValue)}{unit}
          </p>
        </div>
      </div>
      <div className="w-full h-8 bg-muted rounded-full overflow-hidden">
        <div
          className="h-full bg-gradient-to-r from-blue-500 to-purple-500 rounded-full transition-all duration-100"
          style={{ width: `${widthPercentage}%` }}
        />
      </div>
    </div>
  );
}
```

### 5. Slide 컴포넌트 수정

**파일**: `/src/components/Slide/Slide004.tsx`
**수정 대상**: 전체 컴포넌트를 애니메이션 지원으로 교체

**파일**: `/src/components/Slide/Slide005.tsx`
**수정 대상**: 전체 컴포넌트를 애니메이션 지원으로 교체

## 재사용 가능한 연관 코드

### 기존 활용 가능한 코드

1. **Pinning Context** (`/src/contexts/pinning.tsx`)
   - `useSectionPinning(sectionIndex)` hook
   - `SectionPinningState` 타입
   - 검증된 상태 관리 로직

2. **GSAP 설정** (`/src/components/Test/index.tsx`)
   - ScrollTrigger 설정 로직 (Line 218-262)
   - 섹션 ref 관리 시스템
   - 디바운싱 처리 방식

3. **shadcn/ui 컴포넌트**
   - `Card`, `CardContent` 레이아웃 컴포넌트
   - `cn()` 유틸리티 함수
   - 기존 디자인 시스템

### 확장 가능한 패턴

1. **애니메이션 Hook 패턴**
   - `useCountAnimation`을 기반으로 다른 애니메이션 타입 확장 가능
   - `useProgressAnimation`, `useScaleAnimation` 등

2. **컴포넌트 조합 패턴**
   - `AnimatedBar` + `AnimatedHorizontalBar` 조합으로 복합 차트 구성
   - props 인터페이스 통일로 동적 차트 타입 전환 가능

## Test Code 추가 및 수정 필요 부분

### 1. Unit Tests

**파일**: `/src/hooks/__tests__/useCountAnimation.test.ts` (신규)

- 애니메이션 진행률 검증
- duration 파라미터 동작 확인
- isActive false일 때 초기화 검증

**파일**: `/src/components/ui/__tests__/animated-bar.test.tsx` (신규)

- props 전달 및 렌더링 검증
- 애니메이션 활성화/비활성화 상태 테스트
- 접근성 속성 확인

### 2. Integration Tests

**파일**: `/src/components/Test/__tests__/pinning-integration.test.tsx` (신규)

- Slide 컴포넌트와 pinning 시스템 연동 테스트
- sectionIndex 전달 및 상태 업데이트 검증
- 애니메이션 트리거 타이밍 테스트

### 3. E2E Tests

**파일**: `/e2e/slide-animations.spec.ts` (신규)

- 실제 스크롤 동작을 통한 애니메이션 테스트
- 성능 메트릭 수집 (FPS, 메모리 사용량)
- 크로스 브라우저 호환성 검증

### 4. 기존 테스트 수정

**파일**: `/src/components/Slide/__tests__/Slide004.test.tsx`

- `sectionIndex` prop 추가에 따른 테스트 케이스 업데이트
- 애니메이션 상태 변화 시나리오 추가

**파일**: `/src/components/Slide/__tests__/Slide005.test.tsx`

- 동일한 방식으로 기존 테스트 업데이트

## 구현 우선순위

1. **Phase 1**: 타입 정의 및 기본 인프라 (1-2시간)
   - `SlideProps` 타입 추가
   - Test 컴포넌트 수정으로 `sectionIndex` 전달

2. **Phase 2**: 애니메이션 시스템 구축 (3-4시간)
   - `useCountAnimation` hook 구현
   - 기본 애니메이션 컴포넌트 개발

3. **Phase 3**: Slide 컴포넌트 적용 (2-3시간)
   - Slide004, Slide005 리팩토링
   - pinning 상태 연동 구현

4. **Phase 4**: 테스트 및 최적화 (2-3시간)
   - 단위 테스트 작성
   - 성능 최적화 및 버그 수정

## 위험 요소 및 대응 방안

### 1. 성능 저하 위험

- **문제**: 다수의 애니메이션 동시 실행 시 프레임 드롭
- **대응**: `requestAnimationFrame` 기반 최적화, 애니메이션 중복 실행 방지

### 2. 타입 호환성 문제

- **문제**: 기존 Slide 컴포넌트들의 props 변경으로 인한 타입 에러
- **대응**: `SlideProps`를 optional로 시작, 점진적 마이그레이션

### 3. 애니메이션 동기화 이슈

- **문제**: pinning 상태 변화와 애니메이션 시작점 불일치
- **대응**: debouncing 로직 활용, 상태 변화 감지 정확성 향상

이 계획을 통해 Slide 컴포넌트들이 pinning 상태를 효과적으로 활용하여 사용자 경험을 크게 향상시킬 수 있을 것입니다.
