# PhoneSection 컴포넌트 Owner 중심 상태 관리 리팩토링

## 작업의 목적

PhoneSection 컴포넌트의 미완성된 상태 관리 로직을 Owner(Entity) 중심의 상태 추출 함수로 단순화하여 유지보수성과 타입 안전성을 향상시킨다. scenario.tsx의 AgenticStep과 일관된 상태 계산 구조를 구축하고, 부모-자식 컴포넌트 간 매개변수 의존성을 줄인다.

## 현재의 상태 / 문제점

### 기존 코드의 문제점

1. **미완성된 useMemo 로직**: 56-83번 라인의 useMemo가 비어있고 문법 오류 포함 (prev, getInvolvedEnity 등 정의되지 않은 변수)
2. **복잡한 Props 의존성**: contactName, callerName, callerEntity 등을 부모에서 전달받거나 계산해야 함
3. **타입 안전성 부족**: getInvolvedEnity 함수가 정의되지 않고 any 타입 사용 가능성
4. **중복된 상태 관리**: entity.state와 scenario.steps 기반 상태가 불일치할 수 있음
5. **불완전한 Call Overlay Props**: callerEntity, calleeEntity 등이 비어있거나 하드코딩됨
6. **매개변수 과다**: 부모에서 전달받는 props와 자식에게 전달하는 props가 많아 결합도 높음

### 현재 파일 구조

```text
src/components/shared/PhoneSection/
├── index.tsx (메인 컴포넌트, 리팩토링 대상)
```

## 관련 코드의 통합 구조 (Birdeye View)

```text
┌─────────────────────────────────────────┐
│ Scenario Context                        │
│ ├── AgenticStep (send-message,          │
│ │   make-call, accept-call, etc.)       │
│ ├── Entity (Human/AI)                   │
│ └── Message/Call types                  │
└─────────────┬───────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────┐
│ PhoneSection Component                  │
│ ├── getOwnerPhoneState (Owner 중심)     │
│ ├── 자체 상태 계산 (props 의존성 감소)  │
│ ├── Screen determination logic          │
│ └── Call overlays (자동 props 계산)     │
└─────────────┬───────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────┐
│ Child Components                        │
│ ├── PhoneFrame                          │
│ ├── MessageScreen                       │
│ ├── VoiceScreen                         │
│ ├── HomeScreen                          │
│ └── Call Overlays (간소화된 props)      │
└─────────────────────────────────────────┘
```

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **타입 안전성**: 모든 Entity 참조가 Scenario 타입 기반으로 처리, any 타입 제거
2. **자체 완결성**: Owner 상태를 내부에서 계산하여 외부 의존성 최소화
3. **Props 간소화**: contactName 등 불필요한 props 제거, Call Overlay props 자동 계산
4. **일관된 상태**: scenario.steps 기반으로 모든 상태 결정, entity.state 의존성 제거
5. **미완성 코드 제거**: useMemo의 문법 오류 및 정의되지 않은 변수 해결
6. **결합도 감소**: 부모-자식 컴포넌트 간 매개변수 최소화

### 리팩토링 후 상태 구조

```typescript
// getOwnerPhoneState 함수 결과
interface OwnerState {
  phoneState: 'idle' | 'ring-incoming' | 'ring-outgoing' | 'calling' | 'messaging';
  fromEntity?: Entity;
  toEntity?: Entity;
}

// PhoneSection Props 간소화
interface PhoneSectionProps {
  entity: HumanState | null;
  label: string;
  labelColor: string;
  animationDirection: 'left' | 'right';
  // contactName 제거 - 내부에서 계산
  location?: 'customer' | 'server';
  statusBarVariant?: 'default' | 'program';
  voiceBubbleVariant?: 'default' | 'program';
}
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. Import 문 수정

```typescript
// 기존
import type { Message, HumanState } from '@/contexts/scenario';
import { useMemo } from 'react';

// 변경 후
import type { Message, HumanState, Entity, AIAgentState, AgenticStep, Scenario } from '@/contexts/scenario';
import { useMemo } from 'react';
```

### 2. getOwnerPhoneState 함수 추가

```typescript
// PhoneSection 컴포넌트 외부에 추가
function getOwnerPhoneState(owner: Entity, scenario: Scenario): {
  phoneState: 'idle' | 'ring-incoming' | 'ring-outgoing' | 'calling' | 'messaging';
  fromEntity?: Entity;
  toEntity?: Entity;
} {
  // Owner가 관여한 step만 필터링
  const lastStep = scenario.steps
    .filter(
      (step: AgenticStep) =>
        step.action.from === owner.name || step.action.to === owner.name
    )
    .at(-1);

  if (!lastStep) return { phoneState: 'idle' };

  // Entity 검색 함수
  function findEntityByName(scenario: Scenario, name: string): Entity | undefined {
    if (scenario.customer?.name === name) return scenario.customer;
    const agent = scenario.agents?.find((a: AIAgentState) => a.name === name);
    if (agent) return agent;
    const server = scenario.servers?.find((s: Entity) => s.name === name);
    if (server) return server;
    return undefined;
  }

  switch (lastStep.type) {
    case 'make-call':
      return {
        phoneState: lastStep.action.from === owner.name ? 'ring-outgoing' : 'ring-incoming',
        fromEntity: findEntityByName(scenario, lastStep.action.from),
        toEntity: findEntityByName(scenario, lastStep.action.to),
      };
    case 'accept-call':
      return {
        phoneState: 'calling',
        fromEntity: findEntityByName(scenario, lastStep.action.from),
        toEntity: findEntityByName(scenario, lastStep.action.to),
      };
    case 'finish-call':
      return { phoneState: 'idle' };
    case 'send-message':
      return {
        phoneState:
          lastStep.action.type === 'voice' || lastStep.action.type === 'dtmf'
            ? 'calling'
            : 'messaging',
        fromEntity: findEntityByName(scenario, lastStep.action.from),
        toEntity: findEntityByName(scenario, lastStep.action.to),
      };
    default:
      return { phoneState: 'idle' };
  }
}
```

### 3. PhoneSection Props 간소화

```typescript
// 기존 Props
interface PhoneSectionProps {
  entity: HumanState | null;
  label: string;
  labelColor: string;
  animationDirection: 'left' | 'right';
  contactName?: string;  // 제거
  location?: 'customer' | 'server';
  statusBarVariant?: 'default' | 'program';
  voiceBubbleVariant?: 'default' | 'program';
}

// 변경 후 Props (contactName 제거)
interface PhoneSectionProps {
  entity: HumanState | null;
  label: string;
  labelColor: string;
  animationDirection: 'left' | 'right';
  location?: 'customer' | 'server';
  statusBarVariant?: 'default' | 'program';
  voiceBubbleVariant?: 'default' | 'program';
}
```

### 4. 미완성 useMemo 로직 교체

```typescript
// 기존 (56-83라인 제거)
useMemo(() => {
  if (state.steps) {
    const { steps } = state;
    const lastStep = steps[steps.length - 1];
    if (lastStep) {
      const involved = getInvolvedEnity(lastStep.action, state); // 정의되지 않은 함수
      if(!involved) {
        return prev // 정의되지 않은 변수
      }
      // ... 미완성 로직
    }
  }
}, [state.steps]);

// 변경 후
const ownerState = useMemo(() => {
  if (!entity) return { phoneState: 'idle' as const };
  return getOwnerPhoneState(entity, state);
}, [entity, state.steps]);

const contactName = useMemo(() => {
  const otherEntity = ownerState.fromEntity?.name === entity?.name 
    ? ownerState.toEntity 
    : ownerState.fromEntity;
  return otherEntity?.displayName || otherEntity?.name || 'Contact';
}, [ownerState, entity]);

const currentScreen = useMemo(() => {
  switch (ownerState.phoneState) {
    case 'calling': return 'voice';
    case 'ring-incoming':
    case 'ring-outgoing': return 'home-with-overlay';
    case 'messaging': return 'message';
    default: return 'home';
  }
}, [ownerState.phoneState]);
```

### 5. Call Overlay Props 자동 계산

```typescript
// 기존 (하드코딩되거나 비어있음)
<IncomingCallOverlay
  state={entity.state}
  callerName={callerName}  // 정의되지 않은 변수
  callerEntity={callerEntity}  // 정의되지 않은 변수
  ownerName={entity.name || 'Unknown'}
/>
<OutgoingCallOverlay
  calleeEntity={ }  // 비어있음
/>

// 변경 후 (ownerState에서 자동 계산)
const incomingCallProps = useMemo(() => ({
  state: ownerState.phoneState === 'ring-incoming' ? 'ring' : 'idle',
  callerName: ownerState.fromEntity?.displayName || ownerState.fromEntity?.name || 'Unknown',
  callerEntity: ownerState.fromEntity,
  ownerName: entity?.name || 'Unknown',
}), [ownerState, entity]);

const outgoingCallProps = useMemo(() => ({
  state: ownerState.phoneState === 'ring-outgoing' ? 'ring' : 'idle',
  calleeName: ownerState.toEntity?.displayName || ownerState.toEntity?.name || 'Unknown',
  calleeEntity: ownerState.toEntity,
  ownerName: entity?.name || 'Unknown',
}), [ownerState, entity]);

<IncomingCallOverlay {...incomingCallProps} />
<OutgoingCallOverlay {...outgoingCallProps} />
```

### 6. 화면 상태 결정 로직 단순화

```typescript
// 기존 (entity.state 의존)
{entity?.state === 'call' ? (
  <VoiceScreen ... />
) : entity?.state === 'idle' ? (
  <HomeScreen ... />
) : entity?.state === 'ring' ? (
  <HomeScreen ... />  // ring과 idle이 같은 화면
) : (
  <MessageScreen ... />
)}

// 변경 후 (ownerState.phoneState 기반)
{currentScreen === 'voice' && (
  <VoiceScreen
    contactName={contactName}  // 자동 계산된 값
    ...
  />
)}
{(currentScreen === 'home' || currentScreen === 'home-with-overlay') && (
  <HomeScreen ... />
)}
{currentScreen === 'message' && (
  <MessageScreen
    contactName={contactName}  // 자동 계산된 값
    ...
  />
)}
```

## 재사용 가능한 연관 코드

### 관련 파일 및 인터페이스

1. **`src/contexts/scenario.tsx`**
   - `AgenticStep` 타입 (액션 타입 정의)
   - `Entity`, `HumanState`, `AIAgentState` 타입
   - `Scenario` 타입 (entity 검색에 사용)

2. **`src/components/shared/CallScreen/`**
   - `IncomingCallOverlay` (ring-incoming 상태에서 사용)
   - `OutgoingCallOverlay` (ring-outgoing 상태에서 사용)

3. **`src/hooks/useScenario.ts`**
   - scenario 상태 구독 및 steps 배열 접근

### 재사용 가능한 유틸리티

```typescript
// Owner 중심 상태 추출 함수 (다른 Phone 관련 컴포넌트에서도 활용 가능)
function getOwnerPhoneState(owner: Entity, scenario: Scenario): OwnerState

// Entity 검색 함수 (다른 컴포넌트에서도 활용 가능)
function findEntityByName(scenario: Scenario, name: string): Entity | undefined

// Contact name 추출 함수 (다른 컴포넌트에서도 활용 가능)
function getContactName(ownerState: OwnerState, owner: Entity): string
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 추가 필요

1. **getOwnerPhoneState 함수 테스트**
   ```typescript
   describe('getOwnerPhoneState', () => {
     it('should return ring-outgoing when owner makes call', () => {
       const owner = { name: 'user', type: 'human' };
       const scenario = {
         steps: [{ type: 'make-call', action: { from: 'user', to: 'agent' } }],
         customer: owner,
         agents: [{ name: 'agent', type: 'ai' }],
         servers: []
       };
       const result = getOwnerPhoneState(owner, scenario);
       expect(result.phoneState).toBe('ring-outgoing');
       expect(result.fromEntity?.name).toBe('user');
       expect(result.toEntity?.name).toBe('agent');
     });
     
     it('should return ring-incoming when owner receives call', () => {
       const owner = { name: 'user', type: 'human' };
       const scenario = {
         steps: [{ type: 'make-call', action: { from: 'agent', to: 'user' } }],
         customer: owner,
         agents: [{ name: 'agent', type: 'ai' }],
         servers: []
       };
       const result = getOwnerPhoneState(owner, scenario);
       expect(result.phoneState).toBe('ring-incoming');
     });
   });
   ```

2. **PhoneSection 컴포넌트 통합 테스트**
   ```typescript
   describe('PhoneSection', () => {
     it('should render voice screen when owner is calling', () => {
       const entity = { name: 'user', type: 'human', state: 'idle' };
       const scenario = {
         steps: [
           { type: 'make-call', action: { from: 'user', to: 'agent' } },
           { type: 'accept-call', action: { from: 'user', to: 'agent' } }
         ]
       };
       // Mock useScenario hook
       render(<PhoneSection entity={entity} ... />);
       expect(screen.getByTestId('voice-screen')).toBeInTheDocument();
     });
   });
   ```

3. **Contact Name 계산 테스트**
   ```typescript
   describe('Contact Name Calculation', () => {
     it('should use displayName when available', () => {
       const ownerState = {
         fromEntity: { name: 'agent', displayName: 'AI Assistant' },
         toEntity: { name: 'user' }
       };
       const contactName = getContactName(ownerState, { name: 'user' });
       expect(contactName).toBe('AI Assistant');
     });
   });
   ```

### 기존 테스트 수정 필요

- PhoneSection 컴포넌트 렌더링 테스트에서 contactName prop 제거 반영
- Call Overlay 컴포넌트 테스트에서 자동 계산된 props 구조 업데이트
- Mock 데이터에서 Scenario 구조 및 AgenticStep 타입 준수

## 추가 분석 과제

1. **Performance 분석**: getOwnerPhoneState 함수의 steps 필터링 성능 최적화 방안
2. **Memoization 전략**: useMemo 의존성 배열 최적화 및 불필요한 리렌더링 방지
3. **Error Handling**: Entity를 찾을 수 없는 경우의 fallback 처리 방안
4. **확장성**: 다른 Phone 관련 컴포넌트에서 getOwnerPhoneState 재사용 가능성 분석
5. **idempotent 검증**: 동일한 scenario.steps에 대해 항상 동일한 결과 반환 확인