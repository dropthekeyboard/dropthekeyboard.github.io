# Refactoring Plan: 스크롤 진행률 기반 스토리텔링 페이지 추가 및 뷰 전환 시스템 구현

## 작업의 목적

기존의 선택 기반 데모 시스템에 **패널 기반 스크롤 진행률 스토리텔링 페이지**를 추가하여, 사용자가 스크롤을 통해 직접 시나리오 진행을 제어할 수 있도록 한다. **개별 패널 단위로 구성된 모듈식 스토리 구조**를 통해 스크롤 위치가 곧 시나리오 진행률이 되는 직관적인 인터랙션을 제공하며, 손쉬운 스토리 확장과 재사용이 가능한 시스템을 구축한다.

## 현재의 상태 / 문제점

### 현재 구조

- **단일 뷰 모드**: DemoView만 존재하여 3개 섹션(Customer, Agent, Server)이 수평 배치
- **시간 기반 자동 재생**: useScenarioProgress로 고정 간격(1500ms)으로 스텝 순차 실행
- **제한적 사용자 제어**: Play/Pause/Reset 버튼으로만 재생 제어 가능
- **진행률과 UI 분리**: progress 상태와 시각적 피드백 간 연결성 부족

### 문제점

1. **수동적 사용자 경험**: 자동 재생만 가능하고 사용자가 진행 속도나 위치를 직접 제어할 수 없음
2. **스토리 흐름 파악 어려움**: 전체 시나리오에서 현재 위치와 다음 단계 예측 불가능
3. **모던 UX 트렌드 미반영**: 스크롤 기반 진행률 제어 방식 부재
4. **탐색성 부족**: 이전 스텝으로 돌아가거나 특정 지점으로 점프 불가능

## 추가 분석 과제

### 기술적 분석 필요 사항

1. **스크롤 성능 최적화**

- 스크롤 이벤트 리스너의 쓰로틀링 및 디바운싱 전략
- 모바일 디바이스에서의 스크롤 성능 및 배터리 소모 최적화

2. **기존 progress 시스템과의 호환성**

- useScenarioProgress의 타이머 기반 로직과 스크롤 기반 로직 간 충돌 방지
- 두 뷰 모드의 진행 상태는 분리한다: Demo 모드는 타이머 기반으로 진행률을 변경(mutate)하고, Storytelling 모드는 스크롤 기반 읽기 전용 미리보기만 제공(동기화하지 않음)

3. **스크롤 UX 세부 설계**
   - 스크롤 속도에 따른 스텝 전환 민감도 조정
   - 역방향 스크롤 시 이전 스텝 복원 로직

4. **패널 기반 구조 설계**
   - 각 패널의 타입과 역할 정의 (Intro, Demo, Transition, Summary 등)
   - 패널 간 전환 애니메이션 및 상태 관리
   - 동적 패널 추가/제거 시스템

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **이중 뷰 모드 시스템**
   - Demo View: 기존 자동 재생 기반 3컬럼 수평 레이아웃 유지
   - Storytelling View: 스크롤 진행률 기반 시나리오 제어 시스템

2. **스크롤 기반 진행률 제어**
   - 스크롤 위치가 곧 시나리오 진행률 (scrollY / totalHeight = progress / totalSteps)
   - 실시간 스크롤-스텝 동기화로 즉각적인 피드백 제공

3. **패널 기반 모듈식 스토리 구조**
   - 독립적인 패널 컴포넌트로 스토리 구성 (IntroPanel, DemoPanel, TransitionPanel 등)
   - 각 패널별 고유한 스크롤 진행률 범위 할당
   - 패널 추가/제거를 통한 손쉬운 스토리 확장

4. **상태 분리 및 일관성 유지**

- Demo 모드: 기존 progress 시스템(타이머 기반)으로 상태를 변경(mutate)
- Storytelling 모드: 스크롤 진행률에 따른 읽기 전용 미리보기(ScenarioContext 진행률 변경 없음)
- 공통: 시나리오 선택, 테마, agentStyle은 공유

### 성공 판정 기준

- [ ] 스크롤 진행률과 미리보기 스텝 하이라이트가 실시간 반영 (지연 < 50ms)
- [ ] 역방향 스크롤 시 미리보기 하이라이트가 정확히 역전
- [ ] 패널별 스크롤 진행률 매핑 정확성
- [ ] 새로운 패널 추가/제거 시 시스템 안정성 유지

### 1. 패널 기반 시스템 설계

// src/types/storytelling.ts
interface StoryPanel {
id: string;
title: string;
description?: string;
component: React.ComponentType<StoryPanelProps>;
scrollRange: [number, number]; // [시작%, 끝%] 0-1 범위
steps?: AgenticStep[]; // demo 패널의 경우만
duration?: number; // 패널 완료 예상 시간
}

interface StoryPanelProps {
panel: StoryPanel;
isActive: boolean;
progress: number; // 해당 패널 내 진행률 0-1
agentStyle?: 'minimal' | 'formal' | 'hacker';
}

// 스토리 구성 예시
const storyPanels: StoryPanel[] = [
{
id: 'intro',
type: 'intro',
title: 'A2A Demo Introduction',
component: IntroPanel,
scrollRange: [0, 0.1],
},
{
id: 'customer-demo',
type: 'demo',
title: 'Customer Interaction',
component: CustomerDemoPanel,
scrollRange: [0.1, 0.4],
steps: customerSteps,
},
{
id: 'agent-demo',
type: 'demo',
title: 'AI Agent Processing',
component: AgentDemoPanel,
scrollRange: [0.4, 0.7],
steps: agentSteps,
},
{
id: 'server-demo',
type: 'demo',
title: 'Server Response',
component: ServerDemoPanel,
scrollRange: [0.7, 0.9],
steps: serverSteps,
},
{
id: 'summary',
type: 'summary',
title: 'Demo Summary',
component: SummaryPanel,
scrollRange: [0.9, 1],
},
];

````

### 2. 새로운 스크롤 기반 패널 진행률 훅 생성 (읽기 전용)

```typescript
// src/hooks/useScrollProgress.ts
// 주의: Storytelling 모드는 읽기 전용 미리보기입니다. ScenarioContext의 진행률은 변경하지 않습니다.
interface UseScrollProgressReturn {
  scrollProgress: number; // 전체 스크롤 진행률 0-1
  currentPanel: StoryPanel | null;
  currentPanelProgress: number; // 현재 패널 내 진행률 0-1
  previewStepIndex: number; // 현재 패널 내 미리보기 스텝 인덱스
  previewTotalSteps: number; // 현재 패널 내 전체 스텝 수
  bindScrollToProgress: boolean;
  setBindScrollToProgress: (bind: boolean) => void;
}

const useScrollProgress = (panels: StoryPanel[]): UseScrollProgressReturn => {
  const [scrollProgress, setScrollProgress] = useState(0);
  const [bindScrollToProgress, setBindScrollToProgress] = useState(false);

  const currentPanel = useMemo(() => {
    return panels.find(
      (panel) =>
        scrollProgress >= panel.scrollRange[0] &&
        scrollProgress <= panel.scrollRange[1]
    ) || null;
  }, [scrollProgress, panels]);

  const currentPanelProgress = useMemo(() => {
    if (!currentPanel) return 0;
    const [start, end] = currentPanel.scrollRange;
    const panelRange = Math.max(end - start, 1e-6);
    const progressInPanel = (scrollProgress - start) / panelRange;
    return Math.min(Math.max(progressInPanel, 0), 1);
  }, [scrollProgress, currentPanel]);

  const previewTotalSteps = currentPanel?.type === 'demo' && currentPanel.steps
    ? currentPanel.steps.length
    : 0;
  const previewStepIndex = previewTotalSteps
    ? Math.min(
        Math.max(Math.floor(currentPanelProgress * previewTotalSteps), 0),
        previewTotalSteps - 1
      )
    : 0;

  useEffect(() => {
    if (!bindScrollToProgress) return;
    let ticking = false;
    const handler = () => {
      if (ticking) return;
      ticking = true;
      requestAnimationFrame(() => {
        const scrollTop = window.scrollY;
        const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
        const ratio = scrollHeight > 0 ? Math.min(scrollTop / scrollHeight, 1) : 0;
        setScrollProgress(ratio);
        ticking = false;
      });
    };
    window.addEventListener('scroll', handler, { passive: true });
    return () => window.removeEventListener('scroll', handler);
  }, [bindScrollToProgress]);

  return {
    scrollProgress,
    currentPanel,
    currentPanelProgress,
    previewStepIndex,
    previewTotalSteps,
    bindScrollToProgress,
    setBindScrollToProgress,
  };
};
````

### 3. StorytellingPage 컴포넌트 패널 기반으로 재구성

```typescript
// src/components/StorytellingPage/index.tsx
export function StorytellingPage({ agentStyle }: { agentStyle: string }) {
  const { currentScenario } = useScenario();
  const {
    currentPanel,
    currentPanelProgress,
    setBindScrollToProgress
  } = useScrollProgress(storyPanels);

  // 컴포넌트 마운트 시 스크롤-진행률 연동 활성화
  useEffect(() => {
    setBindScrollToProgress(true);
    return () => setBindScrollToProgress(false);
  }, [setBindScrollToProgress]);

  // 전체 스크롤 높이를 패널 수에 맞게 설정
  const scrollHeight = storyPanels.length * 100;

  return (
    <div
      className="storytelling-container"
      style={{ height: `${scrollHeight}vh` }}
    >
      {/* 스크롤 진행률 인디케이터 */}
      <ScrollProgressIndicator
        panels={storyPanels}
        currentPanelId={currentPanel?.id}
        previewStepIndex={previewStepIndex}
        previewTotalSteps={previewTotalSteps}
      />

      {/* 패널별 렌더링 */}
      {storyPanels.map((panel, index) => (
        <PanelContainer
          key={panel.id}
          panel={panel}
          isActive={currentPanel?.id === panel.id}
          progress={currentPanel?.id === panel.id ? currentPanelProgress : 0}
          agentStyle={agentStyle}
          style={{
            position: 'absolute',
            top: `${(panel.scrollRange[0] * scrollHeight)}vh`,
            height: `${((panel.scrollRange[1] - panel.scrollRange[0]) * scrollHeight)}vh`
          }}
        />
      ))}
    </div>
  );
}
```

```typescript
// src/components/StorytellingPage/panels/IntroPanel.tsx
const IntroPanel: React.FC<StoryPanelProps> = ({ panel, isActive, progress }) => {
  return (
    <div className="flex items-center justify-center h-full bg-gradient-to-br from-blue-50 to-indigo-100">
      <div className="text-center space-y-6 max-w-2xl px-8">
        <motion.h1
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: isActive ? 1 : 0.3, y: isActive ? 0 : 50 }}
          className="text-5xl font-bold text-gray-800"
        >
          {panel.title}
        </motion.h1>
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: isActive ? 1 : 0.3 }}
          transition={{ delay: 0.2 }}
          className="text-xl text-gray-600"
        >
          Experience the power of Agent-to-Agent communication
        </motion.p>
        <motion.div
          className="w-full bg-gray-200 rounded-full h-2 mt-8"
          initial={{ scaleX: 0 }}
          animate={{ scaleX: isActive ? progress : 0 }}
        >
          <div
            className="bg-blue-600 h-2 rounded-full transition-all duration-300"
            style={{ width: `${progress * 100}%` }}
          />
        </motion.div>
      </div>
    </div>
  );
};

// src/components/StorytellingPage/panels/DemoPanel.tsx
const CustomerDemoPanel: React.FC<StoryPanelProps> = ({ panel, isActive, progress, agentStyle }) => {
  return (
    <div className="grid grid-cols-2 h-full">
      {/* 왼쪽: 데모 영역 */}
      <div className="flex items-center justify-center bg-white">
        <div className="w-full max-w-md">
          <CustomerSection />
        </div>
      </div>

      {/* 오른쪽: 설명 영역 */}
      <div className="flex items-center bg-gray-50 p-8">
        <div className="space-y-4">
          <h2 className="text-3xl font-bold text-gray-800">{panel.title}</h2>
          <p className="text-lg text-gray-600">
            Watch as the customer initiates contact with our AI system
          </p>
          <div className="space-y-2">
            {panel.steps?.map((step, index) => (
              <div
                key={index}
                className={cn(
                  "p-3 rounded-lg transition-all duration-300",
                  index <= (progress * (panel.steps?.length || 1))
                    ? "bg-green-100 text-green-800"
                    : "bg-gray-100 text-gray-500"
                )}
              >
                Step {index + 1}: {getStepDescription(step)}
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
};

// src/components/StorytellingPage/panels/TransitionPanel.tsx
const TransitionPanel: React.FC<StoryPanelProps> = ({ panel, isActive, progress }) => {
  return (
    <div className="flex items-center justify-center h-full bg-gradient-to-r from-indigo-500 to-purple-600">
      <div className="text-center text-white space-y-4">
        <motion.div
          animate={{ rotate: isActive ? 360 : 0 }}
          transition={{ duration: 2, repeat: isActive ? Infinity : 0 }}
          className="mx-auto w-16 h-16 border-4 border-white border-t-transparent rounded-full"
        />
        <h2 className="text-2xl font-semibold">Processing...</h2>
        <p className="text-lg opacity-90">AI Agent is analyzing the request</p>
      </div>
    </div>
  );
};
```

```typescript
// src/utils/panelFactory.ts
class StoryPanelFactory {
  private static panelRegistry = new Map<
    string,
    React.ComponentType<StoryPanelProps>
  >();

  static registerPanel(
    type: string,
    component: React.ComponentType<StoryPanelProps>
  ) {
    this.panelRegistry.set(type, component);
  }

  static createPanel(config: Omit<StoryPanel, 'component'>): StoryPanel {
    const component = this.panelRegistry.get(config.type);
    if (!component) {
      throw new Error(`Panel type '${config.type}' not registered`);
    }

    return {
      ...config,
      component,
    };
  }

  static getAvailableTypes(): string[] {
    return Array.from(this.panelRegistry.keys());
  }
}

// 패널 타입 등록
StoryPanelFactory.registerPanel('intro', IntroPanel);
StoryPanelFactory.registerPanel('demo', DemoPanel);
StoryPanelFactory.registerPanel('transition', TransitionPanel);
StoryPanelFactory.registerPanel('summary', SummaryPanel);

// 동적 스토리 구성 예시
const createStoryFromScenario = (scenario: Scenario): StoryPanel[] => {
  const panels: StoryPanel[] = [];

  // Intro 패널
  panels.push(
    StoryPanelFactory.createPanel({
      id: 'intro',
      type: 'intro',
      title: scenario.title,
      description: scenario.description,
      scrollRange: [0, 0.1],
    })
  );

  // 각 엔티티별 Demo 패널 자동 생성
  const entities = ['customer', 'agent', 'server'];
  entities.forEach((entity, index) => {
    const entitySteps = scenario.steps.filter((step) =>
      isRelevantAction(step, entity as any)
    );

    if (entitySteps.length > 0) {
      const startRatio = 0.1 + index * 0.25;
      const endRatio = startRatio + 0.2;

      panels.push(
        StoryPanelFactory.createPanel({
          id: `${entity}-demo`,
          type: 'demo',
          title: `${entity.charAt(0).toUpperCase() + entity.slice(1)} Demo`,
          scrollRange: [startRatio, endRatio],
          steps: entitySteps,
        })
      );
    }
  });

  // Summary 패널
  panels.push(
    StoryPanelFactory.createPanel({
      id: 'summary',
      type: 'summary',
      title: 'Demo Complete',
      scrollRange: [0.9, 1],
    })
  );

  return panels;
};
```

### 4. App.tsx - 뷰 모드 상태 관리 추가

```typescript
// 기존
function App() {
  const { theme, toggleTheme } = useTheme();
  const [agentStyle, setAgentStyle] = useState<'minimal' | 'formal' | 'hacker'>('hacker');

// 수정 후
function App() {
  const { theme, toggleTheme } = useTheme();
  const [agentStyle, setAgentStyle] = useState<'minimal' | 'formal' | 'hacker'>('hacker');
  const [viewMode, setViewMode] = useState<'demo' | 'storytelling'>('demo');

  return (
    <div className={`app ${theme}`}>
      <ScenarioContextProvider>
        <ControlHeader
          onThemeToggle={toggleTheme}
          onAgentStyleChange={setAgentStyle}
          onViewModeChange={setViewMode}
          currentViewMode={viewMode}
        />
        {viewMode === 'demo' ? (
          <DemoView agentStyle={agentStyle} />
        ) : (
          <StorytellingPage agentStyle={agentStyle} />
        )}
      </ScenarioContextProvider>
    </div>
  );
}
```

### 5. ControlHeader/index.tsx - 뷰 토글 버튼 추가

```typescript
// 인터페이스 확장
interface ControlHeaderProps {
  onThemeToggle: () => void;
  onAgentStyleChange?: (style: 'minimal' | 'formal' | 'hacker') => void;
  onViewModeChange?: (mode: 'demo' | 'storytelling') => void;
  currentViewMode?: 'demo' | 'storytelling';
  playbackInterval?: number;
  className?: string;
}

// 토글 버튼 추가 (ThemeToggle 옆에 배치)
<div className="flex items-center space-x-2">
  <ViewModeToggle
    currentMode={currentViewMode}
    onToggle={onViewModeChange}
  />
  <ThemeToggle onToggle={onThemeToggle} />
</div>
```

### 6. ScrollProgressIndicator 및 ScrollStepGuide 컴포넌트

```typescript
// src/components/StorytellingPage/ScrollProgressIndicator.tsx
type IndicatorProps = {
  panels: StoryPanel[];
  currentPanelId?: string;
  previewStepIndex: number;
  previewTotalSteps: number;
};

const ScrollProgressIndicator: React.FC<IndicatorProps> = ({
  panels,
  currentPanelId,
  previewStepIndex,
  previewTotalSteps,
}) => {
  const { scrollProgress } = useScrollProgress(panels);

  const hasSteps = previewTotalSteps > 0;
  return (
    <div className="fixed left-8 top-1/2 -translate-y-1/2 z-20">
      {/* 세로 진행률 바 */}
      <div className="w-1 h-80 bg-gray-300 rounded-full relative">
        <div
          className="w-full bg-primary rounded-full transition-all duration-200"
          style={{ height: `${scrollProgress * 100}%` }}
          aria-valuenow={Math.round(scrollProgress * 100)}
          aria-valuemin={0}
          aria-valuemax={100}
          role="progressbar"
        />

        {/* 현재 패널의 미리보기 스텝 표시 */}
        {hasSteps && (
          <div
            className="absolute left-4 w-24 text-xs text-center"
            style={{ top: `${scrollProgress * 100}%` }}
            aria-live="polite"
          >
            {previewStepIndex + 1} / {previewTotalSteps}
          </div>
        )}
      </div>

      {/* 현재 패널의 스텝 마커 */}
      {hasSteps && (
        <div className="absolute left-0 top-0 w-1 h-80">
          {Array.from({ length: previewTotalSteps }).map((_, index) => (
            <div
              key={index}
              className={cn(
                "absolute w-3 h-3 rounded-full border-2 border-white -left-1",
                index <= previewStepIndex ? "bg-primary" : "bg-gray-300"
              )}
              style={{ top: `${(index / Math.max(previewTotalSteps - 1, 1)) * 100}%` }}
            />
          ))}
        </div>
      )}
    </div>
  );
};

// src/components/StorytellingPage/ScrollStepGuide.tsx
const ScrollStepGuide = ({ step, index }: { step: AgenticStep, index: number }) => {
  const getStepDescription = (step: AgenticStep) => {
    switch (step.type) {
      case 'send-message':
        return `${step.action.from} → ${step.action.to}: "${step.action.content}"`;
      case 'make-call':
        return `${step.action.from} calls ${step.action.to}`;
      case 'accept-call':
        return `${step.action.to} answers the call`;
      case 'finish-call':
        return `Call ended between ${step.action.from} and ${step.action.to}`;
      default:
        return 'Unknown step';
    }
  };

  return (
    <div className="absolute right-8 top-1/2 transform -translate-y-1/2
                    bg-black/80 text-white p-4 rounded-lg max-w-sm">
      <div className="text-sm opacity-60">Step {index + 1}</div>
      <div className="text-base">{getStepDescription(step)}</div>
    </div>
  );
};
```

## 재사용 가능한 연관 코드

### 완전 재사용 가능한 컴포넌트

1. **`/src/components/DemoView/CustomerSection/index.tsx`**
   - 기능: PhoneSection 래퍼, customer 상태 연결
   - 인터페이스: props 없음, useScenario 훅 의존
   - 재사용: 스토리텔링 페이지에서 동일하게 사용

2. **`/src/components/DemoView/AgentSection/index.tsx`**
   - 기능: TerminalSection 래퍼, agent 관련 steps 필터링
   - 인터페이스: `{ agentStyle?: 'minimal' | 'formal' | 'hacker' }`
   - 재사용: agentStyle prop 전달하여 동일 사용

3. **`/src/components/DemoView/ServerSection/index.tsx`**
   - 기능: server 타입에 따른 PhoneSection/TerminalSection 분기
   - 인터페이스: `{ agentStyle?: 'minimal' | 'formal' | 'hacker' }`
   - 재사용: agentStyle prop 전달하여 동일 사용

### 상태 관리 훅

1. **`/src/hooks/useScenario.ts`**
   - 기능: 시나리오 상태, 진행률, 활성 엔티티 관리
   - 재사용: 두 뷰 모드에서 공통 사용
   - 주의: 뷰 전환 시 상태 초기화 방지 필요

2. **`/src/contexts/scenario.tsx`**
   - 기능: ScenarioContextProvider로 전역 상태 제공
   - 재사용: App 레벨에서 두 뷰 모두 커버

### 공통 UI 컴포넌트

1. **`/src/components/shared/PhoneSection/index.tsx`**
2. **`/src/components/shared/TerminalSection/index.tsx`**
3. **`/src/components/ui/*`** (shadcn/ui 컴포넌트들)

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 추가 필요

1. **ViewModeToggle 컴포넌트**

   ```typescript
   // 테스트 케이스
   - 초기 상태 렌더링
   - 클릭 시 onToggle 콜백 호출
   - currentMode에 따른 UI 상태 변경
   ```

2. **StorytellingPage 컴포넌트**

   ```typescript
   // 테스트 케이스
   - agentStyle prop 전달 확인
   - 각 섹션 컴포넌트 렌더링 확인
   - useScenario 훅 정상 동작 확인
   ```

### 통합 테스트 수정 필요

1. **App 컴포넌트 테스트**

   ```typescript
   // 추가 테스트 케이스
   - 뷰 모드 전환 시 올바른 컴포넌트 렌더링
   - 상태 공유 확인 (agentStyle, 시나리오)
   - ScenarioContextProvider 래핑 확인
   ```

### E2E 테스트 시나리오

#### 뷰 전환 플로우

- Demo View → Storytelling View → Demo View
- 시나리오 선택 상태 유지 확인
- agentStyle 설정 유지 확인

#### 스크롤 기반 진행률 테스트

- 스크롤 위치와 미리보기 스텝 하이라이트 일치 정확성
- 역방향 스크롤 시 하이라이트 역전 확인
- 스크롤 성능 모니터링 (FPS 측정)

### 접근성 테스트

1. **키보드 네비게이션**
   - Tab 키로 뷰 토글 버튼 접근
   - Enter/Space 키로 뷰 전환

2. **스크린 리더 호환성**
   - 뷰 모드 변경 시 적절한 안내 메시지
   - 스크롤 진행률 변경 시 컨텍스트 제공

## 구현 단계별 우선순위

### Phase 1: 기본 뷰 전환 시스템 (1-2일)

1. ViewModeToggle 컴포넌트 생성
2. App.tsx 상태 관리 추가
3. ControlHeader 인터페이스 확장

### Phase 2: 패널 기반 스크롤 시스템 (2-3일)

1. StoryPanel 타입 시스템 및 useScrollProgress 훅 구현
2. 패널별 스크롤 진행률 매핑 로직 구현
3. 성능 최적화 (쓰로틀링, 패시브 리스너)

### Phase 3: 기본 패널 컴포넌트 구현 (2-3일)

1. IntroPanel, DemoPanel, TransitionPanel, SummaryPanel 구현
2. PanelContainer 및 패널 전환 시스템 구축
3. 기존 섹션 컴포넌트와 DemoPanel 통합

### Phase 4: 패널 확장성 시스템 (2-3일)

1. StoryPanelFactory 및 동적 패널 등록 시스템
2. createStoryFromScenario 자동 생성 로직
3. 패널 추가/제거 UI 및 관리 도구

### Phase 5: UX 개선 및 테스트 (2-3일)

1. 스크롤 성능 최적화 및 모바일 대응
2. 역방향 스크롤 시 미리보기 하이라이트 정확성 검증
3. 테스트 코드 작성 및 접근성 개선
