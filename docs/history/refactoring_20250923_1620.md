# Refactoring Plan: SlideGSAPSection as Direct GSAPScrollContext Provider

## 작업의 목적

SlideGSAPSection이 복잡한 중간 레이어(PinningContext) 없이 직접 GSAPScrollContext Provider 역할을 하여 GSAP ScrollTrigger의 모든 상태 정보를 실시간으로 자식 컴포넌트에 제공하는 시스템을 구현한다. 이를 통해 더 직접적이고 효율적인 데이터 플로우를 달성하고 성능을 향상시킨다.

## 현재의 상태 / 문제점

### 현재 구조의 한계

1. **복잡한 데이터 플로우**: SlideGSAPSection → PinningContext → useSectionPinning → 개별 컴포넌트
2. **성능 오버헤드**: 전역 Context 시스템으로 인한 불필요한 리렌더링
3. **의존성 복잡도**: ScrollControls가 전역 상태에 의존하여 다른 섹션 정보까지 접근
4. **상태 관리 분산**: GSAP 정보가 여러 레이어에 분산되어 관리

### 현재 데이터 플로우

```text
SlideGSAPSection → ScrollTrigger callbacks → PinningContext (전역)
                                               ↓
                                         useSectionPinning
                                               ↓
                                         ScrollControls/Components
```

### 목표 데이터 플로우

```text
SlideGSAPSection (자체 Provider) → useGSAPScroll → ScrollControls/Components
    ↓ (직접 제공)
실시간 GSAP ScrollTrigger State
```

## 관련 코드의 통합 구조 (Birdeye View)

```text
a2a-demov/
├── src/
│   ├── components/
│   │   ├── Slide/
│   │   │   ├── SlideGSAPSection.tsx     # 핵심 수정 대상 (Provider로 변환)
│   │   │   └── GSAPSlidesPage.tsx       # 슬라이드 컨테이너
│   │   ├── DemoView/
│   │   │   └── index.tsx                # A2A 데모 뷰 (useGSAPScroll 활용)
│   │   └── ControlHeader/
│   │       └── ScrollControls.tsx       # 단순화 대상
│   ├── hooks/
│   │   ├── useGSAPScroll.ts            # 새로 생성 (핵심 훅)
│   │   └── useScrollControls.ts        # 기존 유지
│   └── contexts/
│       └── pinning.tsx                 # 기존 유지 (호환성)
```

### 핵심 연동 포인트

1. **SlideGSAPSection → GSAPScrollContext**: 자체 Provider로 GSAP 상태 제공
2. **useGSAPScroll**: 해당 섹션의 GSAP 상태에 직접 접근
3. **ScrollControls**: useGSAPScroll로 로컬 상태만 활용
4. **독립적 섹션 관리**: 각 슬라이드 섹션이 자체 상태 관리

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **직접적 데이터 플로우**: SlideGSAPSection이 자체 GSAPScrollContext Provider로 동작
2. **성능 최적화**: 전역 상태 의존성 제거 및 로컬 상태 관리
3. **개발자 경험**: 간단한 `useGSAPScroll()` 훅으로 GSAP 정보 접근
4. **독립성**: 각 섹션이 자체적으로 상태 관리

### 해결 판정 기준

- [ ] SlideGSAPSection이 자체 GSAPScrollContext Provider로 동작
- [ ] useGSAPScroll 훅이 progress, direction, velocity, pinning 상태 제공
- [ ] ScrollControls가 useGSAPScroll로 로컬 섹션 상태만 접근
- [ ] 전역 PinningContext 의존성 제거
- [ ] 기존 PinningContext 호환성 유지 (점진적 마이그레이션)

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. GSAPScrollContext 생성 및 Provider 구현

**파일**: `src/components/Slide/SlideGSAPSection.tsx`

```typescript
// 새로운 Context 인터페이스
interface GSAPScrollState {
  progress: number;        // 0-1 범위
  direction: number;       // 1: down, -1: up, 0: stopped
  velocity: number;        // 스크롤 속도
  isActive: boolean;       // ScrollTrigger 활성 상태
  isPinned: boolean;       // 핀 상태
  isEntering: boolean;     // 진입 상태
  isLeaving: boolean;      // 떠나는 상태
}

const GSAPScrollContext = createContext<GSAPScrollState | null>(null);

// Provider로 변환된 SlideGSAPSection
export default function SlideGSAPSection({ children, pin, ...props }) {
  const [gsapState, setGsapState] = useState<GSAPScrollState>({
    progress: 0, direction: 0, velocity: 0,
    isActive: false, isPinned: false, isEntering: false, isLeaving: false
  });

  useGSAP(() => {
    const st = ScrollTrigger.create({
      // 기존 설정...
      onUpdate: (self) => {
        setGsapState(prev => ({
          ...prev,
          progress: self.progress || 0,
          direction: self.direction || 0,
          velocity: self.velocity || 0
        }));
      },
      onToggle: (self) => {
        setGsapState(prev => ({
          ...prev,
          isActive: self.isActive,
          isPinned: pin ? self.isActive : false,
          isEntering: self.isActive && self.direction !== -1,
          isLeaving: !self.isActive && self.direction !== 1
        }));
      }
    });
  });

  return (
    <GSAPScrollContext.Provider value={gsapState}>
      <section>{children}</section>
    </GSAPScrollContext.Provider>
  );
}
```

### 2. useGSAPScroll 훅 구현

**파일**: `src/hooks/useGSAPScroll.ts` (새 파일)

```typescript
export function useGSAPScroll() {
  const context = useContext(GSAPScrollContext);
  if (!context) {
    throw new Error('useGSAPScroll must be used within SlideGSAPSection');
  }

  // 편의 계산값들
  const scrollAmount = useMemo(
    () => Math.round(context.progress * 100),
    [context.progress]
  );
  const isScrollingDown = context.direction > 0;
  const isScrollingUp = context.direction < 0;
  const scrollSpeed = useMemo(
    () => Math.abs(context.velocity),
    [context.velocity]
  );

  return {
    ...context,
    scrollAmount, // 0-100 백분율
    isScrollingDown,
    isScrollingUp,
    scrollSpeed,
    isRapidScroll: scrollSpeed > 1,
  };
}
```

### 3. ScrollControls 단순화

**파일**: `src/components/ControlHeader/ScrollControls.tsx`

```typescript
export function ScrollControls({ threshold = 30 }) {
  const { progressNext, revertToPrev } = useScenario();
  const { isPinned, scrollSpeed, isScrollingDown } = useGSAPScroll();

  // 스크롤 속도에 따른 동적 threshold
  const dynamicThreshold = useMemo(() => {
    return scrollSpeed > 1 ? threshold * 0.5 : threshold;
  }, [threshold, scrollSpeed]);

  useScrollControls({
    enabled: isPinned,
    threshold: dynamicThreshold,
    onProgressNext: progressNext,
    onRevertToPrev: revertToPrev,
  });

  return null;
}
```

## 재사용 가능한 연관 코드

### 기존 호환성 유지 코드

- **`src/contexts/pinning.tsx`**: 기존 시스템과 100% 호환성 유지
- **`src/hooks/useScenario.ts`**: 시나리오 진행 로직 재사용
- **`src/hooks/useScrollControls.ts`**: 기본 스크롤 이벤트 처리 재사용

### 새로운 재사용 가능 컴포넌트

- **`src/hooks/useGSAPScroll.ts`**: 각 섹션별 GSAP 상태 접근 훅
- **GSAPScrollContext**: 다른 GSAP 기반 컴포넌트에서도 재사용 가능

### 활용 가능한 인터페이스

```typescript
// 다른 컴포넌트에서 활용 가능
interface ScrollProgressIndicatorProps {
  showPercentage?: boolean;
  className?: string;
}

function ScrollProgressIndicator({ showPercentage = true }: ScrollProgressIndicatorProps) {
  const { scrollAmount, isScrollingDown } = useGSAPScroll();

  return (
    <div className={`progress-bar ${isScrollingDown ? 'scrolling-down' : ''}`}>
      {showPercentage && <span>{scrollAmount}%</span>}
    </div>
  );
}
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. Context 및 Provider 테스트

**파일**: `src/components/Slide/__tests__/SlideGSAPSection.test.tsx`

```typescript
describe('SlideGSAPSection GSAPScrollContext', () => {
  test('GSAPScrollContext Provider 기능', () => {
    // Context 제공 여부 확인
    // 초기 상태 값 검증
  });

  test('ScrollTrigger 콜백에서 상태 업데이트', () => {
    // onUpdate, onToggle 콜백 시뮬레이션
    // 상태 변화 검증
  });
});
```

### 2. useGSAPScroll 훅 테스트

**파일**: `src/hooks/__tests__/useGSAPScroll.test.ts`

```typescript
describe('useGSAPScroll', () => {
  test('계산된 값들 정확성', () => {
    // scrollAmount, scrollSpeed 등 계산 로직 테스트
  });

  test('Context 밖에서 사용 시 에러', () => {
    // 적절한 에러 메시지 반환 확인
  });
});
```

### 3. 통합 테스트

**파일**: `src/components/__tests__/GSAPIntegration.test.tsx`

```typescript
describe('GSAP Integration', () => {
  test('SlideGSAPSection과 ScrollControls 연동', () => {
    // 전체 데이터 플로우 테스트
    // ScrollControls가 올바른 상태 수신 확인
  });
});
```

### 4. E2E 테스트 시나리오

**파일**: `e2e/gsap-scroll-provider.spec.ts`

```typescript
test('GSAP Provider scroll interaction', async ({ page }) => {
  // 1. 슬라이드 섹션 진입 시 Provider 활성화 확인
  // 2. 스크롤 시 상태 변화 확인
  // 3. ScrollControls 반응 확인
});
```

## 추가 분석 과제

### 1. 성능 영향 분석

- Context Provider 패턴이 기존 전역 상태 대비 성능에 미치는 영향 측정
- 여러 SlideGSAPSection이 동시에 활성화될 때의 메모리 사용량 분석

### 2. 마이그레이션 전략

- 기존 PinningContext 시스템과의 호환성 유지 방안
- 점진적 마이그레이션을 위한 단계별 전환 계획

### 3. 확장성 고려사항

- 향후 추가될 수 있는 GSAP 기반 기능들에 대한 Context 구조 확장성
- 다른 애니메이션 라이브러리와의 호환성 검토

---

**예상 작업 시간**: 1-2일
**우선순위**: 높음 (성능 및 아키텍처 개선의 핵심)
**리스크**: 낮음 (기존 시스템과 병행 가능, 점진적 마이그레이션)
