# DemoView N-Screen 대응 리팩토링 플랜

**작성일**: 2025년 9월 21일 14:30  
**목적**: DemoView 및 하위 컴포넌트들의 N-Screen 대응을 위한 현대적 CSS 기법 적용

## 작업의 목적

DemoView 컴포넌트가 다양한 화면 크기에서 일관된 사용자 경험을 제공하도록 리팩토링합니다. 기존의 px 단위 기반 레이아웃에서 현대적인 CSS 기법을 활용한 완전한 반응형 레이아웃으로 전환합니다.

## 현재의 상태 / 문제점

### 주요 문제점 분석

1. **레이아웃 문제**
   - DemoView의 3개 섹션이 `flex-[0_0_30%]`로 고정되어 90% + gap으로 인한 작은 화면에서 overflow
   - 하드코딩된 px 단위 사용으로 인한 반응성 부족

2. **폰트 크기 문제**
   - px 단위 폰트 크기로 인한 가독성 저하
   - 화면 크기에 따른 적응형 텍스트 미적용

3. **컴포넌트별 세부 문제**
   - MessageBubble: `max-w-[280px]` px 단위로 작은 화면에서 깨짐
   - PhoneFrame: `max-w-[20vw]`는 좋지만 내부 요소들이 px 단위
   - ReasoningAgentSection: 일부 vw/vh 사용하지만 일관성 부족

## 관련 코드의 통합 구조 (Birdeye View)

```text
DemoView (flex layout, 3개 섹션)
├── CustomerSection
│   └── PhoneSection
│       ├── PhoneFrame (max-w-[20vw], aspect-[9/19.5])
│       └── MessageScreen/CallScreen/HomeScreen
│           └── MessageBubble (max-w-[280px] ← 문제)
├── AgentSection
│   └── ReasoningAgentSection/TerminalSection
│       ├── h-[60vh] w-[20vw] ← 양호
│       └── 내부 요소들 px 단위 혼재
└── ServerSection
    └── PhoneSection 또는 ReasoningAgentSection
```

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **완전한 반응형 레이아웃**: 320px부터 4K까지 모든 화면에서 깨지지 않음
2. **적응형 폰트 시스템**: 화면 크기에 따라 자연스럽게 조정되는 텍스트
3. **일관된 크기 체계**: CSS Container Queries와 현대적 뷰포트 단위 활용
4. **성능 최적화**: CSS 변수를 통한 중앙화된 관리

## 더 효과적인 해결 방안

### 1. CSS Container Queries 활용 (2025년 권장)

```css
/* DemoView에 컨테이너 설정 */
.demo-view {
  container: demo-layout / inline-size;
}

/* 컨테이너 크기에 따른 적응형 레이아웃 */
@container demo-layout (max-width: 768px) {
  .demo-sections {
    flex-direction: column;
  }
}

@container demo-layout (min-width: 1200px) {
  .demo-sections {
    gap: clamp(1rem, 2vw, 3rem);
  }
}
```

### 2. 동적 뷰포트 단위 (dvw/dvh) 적용

```css
/* 모바일 브라우저 UI 변화에 대응 */
.demo-view {
  height: 100dvh; /* 동적 뷰포트 높이 */
  width: 100dvw; /* 동적 뷰포트 너비 */
}

.phone-frame {
  max-width: clamp(200px, 20dvw, 400px);
  height: clamp(400px, 60dvh, 800px);
}
```

### 3. clamp() 함수를 활용한 적응형 폰트 시스템

```css
/* TailwindCSS v4 커스텀 유틸리티 */
@theme {
  --font-size-adaptive-xs: clamp(0.75rem, 1.5vw, 0.875rem);
  --font-size-adaptive-sm: clamp(0.875rem, 2vw, 1rem);
  --font-size-adaptive-base: clamp(1rem, 2.5vw, 1.125rem);
  --font-size-adaptive-lg: clamp(1.125rem, 3vw, 1.25rem);
  --font-size-adaptive-xl: clamp(1.25rem, 3.5vw, 1.5rem);
}
```

### 4. CSS Grid 서브그리드 활용

```css
.demo-view {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  container: demo-layout / inline-size;
}
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. DemoView 컴포넌트 개선

```tsx
// src/components/DemoView/index.tsx
export function DemoView({
  className,
  agentStyle = 'reasoning',
}: DemoViewProps) {
  return (
    <div
      id="demoview"
      className={cn(
        // 기존: 'flex gap-4 p-4 h-full items-center pt-10'
        'demo-view grid grid-cols-1 lg:grid-cols-3 gap-[clamp(1rem,2vw,3rem)] p-[clamp(1rem,2vw,2rem)] h-dvh items-center',
        className
      )}
      style={{
        pointerEvents: 'none',
        containerType: 'inline-size',
        containerName: 'demo-layout',
      }}
    >
      {/* 각 섹션에 동일한 클래스 적용 */}
      <div className="demo-section">
        <CustomerSection />
      </div>
      <div className="demo-section">
        <AgentSection agentStyle={agentStyle} />
      </div>
      <div className="demo-section">
        <ServerSection agentStyle={agentStyle} />
      </div>
    </div>
  );
}
```

### 2. PhoneFrame 컴포넌트 개선

```tsx
// src/components/shared/PhoneFrame/index.tsx
export function PhoneFrame({ children, className }: PhoneFrameProps) {
  return (
    <div className={cn(
      'w-full h-full flex items-center justify-center',
      className
    )}>
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ duration: 0.5, ease: 'easeOut' }}
        // 기존: className="relative w-full max-w-[20vw] aspect-[9/19.5]"
        className="relative w-full max-w-[clamp(200px,20dvw,400px)] aspect-[9/19.5]"
        style={{ containerType: 'inline-size' }}
      >
        {/* 나머지 코드 동일 */}
```

### 3. MessageBubble 컴포넌트 개선

```tsx
// src/components/shared/MessageBubble/index.tsx
<div className={cn(
  // 기존: 'relative px-4 py-2 rounded-xl break-words shadow-lg max-w-[280px]'
  'relative px-[clamp(0.75rem,2vw,1rem)] py-[clamp(0.5rem,1.5vw,0.75rem)] rounded-xl break-words shadow-lg',
  'max-w-[clamp(200px,70cqw,350px)]', // Container Query Width 사용
  // 나머지 클래스들...
)}>
```

### 4. CSS 변수 시스템 확장

```css
/* src/index.css에 추가 */
@theme inline {
  /* 기존 변수들... */

  /* 적응형 간격 변수 */
  --spacing-adaptive-xs: clamp(0.25rem, 1vw, 0.5rem);
  --spacing-adaptive-sm: clamp(0.5rem, 1.5vw, 0.75rem);
  --spacing-adaptive-base: clamp(0.75rem, 2vw, 1rem);
  --spacing-adaptive-lg: clamp(1rem, 2.5vw, 1.5rem);
  --spacing-adaptive-xl: clamp(1.5rem, 3vw, 2rem);

  /* 적응형 폰트 크기 변수 */
  --font-size-adaptive-xs: clamp(0.75rem, 1.5vw, 0.875rem);
  --font-size-adaptive-sm: clamp(0.875rem, 2vw, 1rem);
  --font-size-adaptive-base: clamp(1rem, 2.5vw, 1.125rem);
  --font-size-adaptive-lg: clamp(1.125rem, 3vw, 1.25rem);
  --font-size-adaptive-xl: clamp(1.25rem, 3.5vw, 1.5rem);
  --font-size-adaptive-2xl: clamp(1.5rem, 4vw, 2rem);
}

/* Container Query 지원 유틸리티 */
.demo-view {
  container: demo-layout / inline-size;
}

.demo-section {
  container: section / inline-size;
}

/* 반응형 그리드 시스템 */
@container demo-layout (max-width: 768px) {
  .demo-view {
    grid-template-columns: 1fr;
    gap: var(--spacing-adaptive-sm);
  }
}

@container demo-layout (min-width: 769px) and (max-width: 1024px) {
  .demo-view {
    grid-template-columns: 1fr 1fr;
  }
}

@container demo-layout (min-width: 1025px) {
  .demo-view {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

## 재사용 가능한 연관 코드

### 유틸리티 함수 추가

```typescript
// src/lib/responsive-utils.ts
export const responsiveClasses = {
  // 적응형 패딩
  padding: {
    xs: 'p-[var(--spacing-adaptive-xs)]',
    sm: 'p-[var(--spacing-adaptive-sm)]',
    base: 'p-[var(--spacing-adaptive-base)]',
    lg: 'p-[var(--spacing-adaptive-lg)]',
    xl: 'p-[var(--spacing-adaptive-xl)]',
  },

  // 적응형 폰트 크기
  fontSize: {
    xs: 'text-[var(--font-size-adaptive-xs)]',
    sm: 'text-[var(--font-size-adaptive-sm)]',
    base: 'text-[var(--font-size-adaptive-base)]',
    lg: 'text-[var(--font-size-adaptive-lg)]',
    xl: 'text-[var(--font-size-adaptive-xl)]',
    '2xl': 'text-[var(--font-size-adaptive-2xl)]',
  },

  // 적응형 너비
  width: {
    phone: 'w-[clamp(200px,20dvw,400px)]',
    section: 'w-[clamp(300px,30dvw,500px)]',
    container: 'w-[clamp(280px,90dvw,1200px)]',
  },
};

// Container Query 헬퍼
export const containerQuery = {
  wrap: (name: string) => ({
    containerType: 'inline-size' as const,
    containerName: name,
  }),
  classes: {
    mobile: '@container (max-width: 480px)',
    tablet: '@container (min-width: 481px) and (max-width: 768px)',
    desktop: '@container (min-width: 769px)',
  },
};
```

### TailwindCSS v4 커스텀 유틸리티

```css
/* src/index.css에 추가 */
@utility responsive-text {
  font-size: var(--font-size-adaptive-base);
  line-height: 1.5;
}

@utility responsive-padding {
  padding: var(--spacing-adaptive-base);
}

@utility responsive-margin {
  margin: var(--spacing-adaptive-base);
}

@utility adaptive-width {
  width: clamp(200px, 30vw, 400px);
}

@utility adaptive-height {
  height: clamp(300px, 40vh, 600px);
}
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. 반응형 테스트 추가

```typescript
// src/components/DemoView/__tests__/responsive.test.tsx
import { render, screen } from '@testing-library/react';
import { DemoView } from '../index';

describe('DemoView Responsive Tests', () => {
  test('adapts layout on different container sizes', () => {
    // Container Query 테스트 로직
  });

  test('maintains readable font sizes across viewports', () => {
    // clamp() 폰트 크기 테스트
  });

  test('prevents overflow on small screens', () => {
    // 320px 최소 너비 테스트
  });
});
```

### 2. Visual Regression 테스트

```typescript
// cypress/integration/responsive.spec.ts
describe('Responsive Design Tests', () => {
  const viewports = [
    { width: 320, height: 568 }, // iPhone SE
    { width: 768, height: 1024 }, // iPad
    { width: 1920, height: 1080 }, // Desktop
    { width: 3840, height: 2160 }, // 4K
  ];

  viewports.forEach((viewport) => {
    it(`maintains layout integrity at ${viewport.width}x${viewport.height}`, () => {
      cy.viewport(viewport.width, viewport.height);
      cy.visit('/demo');
      cy.matchImageSnapshot(`demo-${viewport.width}x${viewport.height}`);
    });
  });
});
```

## 추가 분석 과제

1. **성능 영향 분석**: Container Queries와 clamp() 함수가 렌더링 성능에 미치는 영향 측정
2. **브라우저 호환성**: 구형 브라우저 대응을 위한 폴백 전략 수립
3. **접근성 검토**: 적응형 폰트 크기가 접근성 가이드라인을 준수하는지 확인
4. **사용자 테스트**: 다양한 디바이스에서의 실제 사용성 검증

## 구현 우선순위

1. **1단계**: CSS 변수 시스템 구축 및 TailwindCSS v4 설정 업데이트
2. **2단계**: DemoView 메인 레이아웃을 CSS Grid + Container Queries로 전환
3. **3단계**: 하위 컴포넌트들의 점진적 마이그레이션 (PhoneFrame → MessageBubble → ReasoningAgentSection)
4. **4단계**: 테스트 코드 작성 및 성능 최적화
5. **5단계**: 브라우저 호환성 검증 및 폴백 구현

---

**결론**: 이 리팩토링 플랜은 단순한 px → vw 변환을 넘어서 2025년 현재 사용 가능한 최신 CSS 기법들을 종합적으로 활용하여 진정한 N-Screen 대응을 구현합니다.
