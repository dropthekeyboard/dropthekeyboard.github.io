# Refactoring Plan: A2A ScrollyTelling 페이지 개발 및 구현

## 작업의 목적

기존의 단순한 데모 중심 StorytellingPage를 A2A (Agent-to-Agent) 스토리텔링에 최적화된 ScrollyTelling 경험으로 변환합니다. scenarios.json과 A2A 문서에 기반한 포괄적인 narrative 구조를 통해 Why Telco → Problem → Solution → Demo Scenarios → Call-to-Action 플로우를 구현하여 A2A 컨셉의 가치 제안을 효과적으로 전달합니다.

## 현재의 상태 / 문제점

### 기존 구현 현황

- **기술적 기반**: React + TypeScript + Framer Motion 기반의 StorytellingPage 구현 완료
- **패널 시스템**: StoryPanel interface와 PanelContainer를 통한 모듈화된 패널 구조
- **스크롤 연동**: useScrollProgress 훅을 통한 scroll-driven 진행률 계산 및 애니메이션
- **기본 패널**: IntroPanel, DemoPanel, SummaryPanel의 3개 기본 패널만 구현

### 현재 문제점 및 제약사항

1. **콘텐츠 구조 부족**: A2A의 핵심 가치 제안과 스토리텔링 요소가 부재
2. **시나리오 활용 미흡**: scenarios.json의 풍부한 Phase별 시나리오 데이터 미활용
3. **단편적 데모**: 단일 DemoPanel로 A2A의 3단계 진화 과정 표현 불가
4. **사용자 경험 부족**: Why → What → How 구조의 설득력 있는 narrative 흐름 부재
5. **확장성 제한**: 새로운 패널 타입 추가 및 동적 스토리 구성 시스템 부재

### 분석된 A2A 핵심 메시지

- **Phase 1**: A2H (Agent to Human) - 전화/SMS 기반 초기 상호작용
- **Phase 2**: Lite Agent - 앱 기반 반자동화 및 파트너 서비스 통합
- **Phase 3**: Full A2A - 완전한 에이전트 간 직접 통신 및 협상

## 추가 분석 과제

1. **시각적 스토리텔링 패턴 연구**
   - ScrollyTelling 모범 사례 분석 (NYTimes, Observable 등)
   - A2A 진화 과정의 효과적인 시각화 방법 탐구

2. **사용자 여정 최적화**
   - 타겟 오디언스별 스토리 진입점 및 관심 포인트 분석
   - 스크롤 속도와 콘텐츠 흡수율 간의 균형점 찾기

3. **성능 및 접근성**
   - 대용량 스크롤 콘텐츠의 성능 최적화 전략
   - 스크린 리더 및 키보드 네비게이션 지원 방안

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

#### 1. 포괄적인 A2A 스토리텔링 구조

```
Hero Section (0-10%) → Why Telco 문제 제기 및 A2A 비전 소개
Problem Section (10-25%) → 현재 통신/서비스 분절화 문제 시각화
Solution Section (25-40%) → A2A 솔루션 개념 및 접근 방식 설명
Phase Evolution (40-70%) → 3단계 진화 과정 시각적 스토리텔링
Demo Scenarios (70-90%) → 각 Phase별 실제 시나리오 데모
Call-to-Action (90-100%) → 다음 단계 및 참여 유도
```

#### 2. 확장 가능한 패널 아키텍처

- 새로운 패널 타입: `hero`, `problem`, `solution`, `phase`, `scenario`, `cta`
- 동적 패널 생성: scenarios.json 기반 자동 스토리 구성
- 패널별 독립적인 애니메이션 및 인터랙션 시스템

#### 3. 풍부한 사용자 경험

- 스크롤 기반 progressive disclosure
- 각 섹션별 적절한 애니메이션 및 시각적 피드백
- 반응형 디자인 및 접근성 준수

### 성공 판정 기준

1. **기능적 완성도**
   - [ ] 6개 섹션의 완전한 스토리텔링 플로우 구현
   - [ ] scenarios.json 데이터 기반 동적 데모 시나리오 생성
   - [ ] 스크롤 진행률에 따른 부드러운 섹션 전환

2. **사용자 경험 품질**
   - [ ] 평균 스크롤 완료율 70% 이상 (추후 측정)
   - [ ] 모든 뷰포트 크기에서 적절한 반응형 동작
   - [ ] WCAG 2.1 AA 수준 접근성 준수

3. **기술적 안정성**
   - [ ] 부드러운 60fps 스크롤 애니메이션 유지
   - [ ] 메모리 사용량 최적화 (이미지/애니메이션 lazy loading)
   - [ ] ESLint 및 TypeScript 컴파일 오류 없음

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 새로운 패널 타입 정의 확장

```typescript
// src/types/storytelling.ts
interface StoryPanel {
  id: string;
  type:
    | 'hero'
    | 'problem'
    | 'solution'
    | 'phase'
    | 'scenario'
    | 'cta'
    | 'intro'
    | 'demo'
    | 'summary';
  title: string;
  description?: string;
  subtitle?: string;
  content?: string;
  phase?: 1 | 2 | 3; // phase 패널용
  scenarioId?: string; // scenario 패널용
  component: React.ComponentType<StoryPanelProps>;
  scrollRange: [number, number];
  steps?: AgenticStep[];
  duration?: number;
  extraProps?: Record<string, unknown>;
}

interface StoryPanelProps {
  panel: StoryPanel;
  isActive: boolean;
  progress: number;
  agentStyle?: 'minimal' | 'formal' | 'hacker';
}

// A2A 특화 컨텍스트
interface A2AStoryContent {
  hero: {
    title: string;
    subtitle: string;
    backgroundVideo?: string;
  };
  problem: {
    title: string;
    painPoints: string[];
    statistics?: { label: string; value: string; description: string }[];
  };
  solution: {
    title: string;
    approach: string;
    benefits: string[];
  };
  phases: {
    [key: number]: {
      title: string;
      description: string;
      keyFeatures: string[];
      scenarios: string[]; // scenario IDs
    };
  };
}
```

### 2. 새로운 패널 컴포넌트 구현

```typescript
// src/components/StorytellingPage/panels/HeroPanel.tsx
const HeroPanel: React.FC<StoryPanelProps> = ({ panel, isActive, progress }) => {
  return (
    <motion.div
      className="relative h-screen flex items-center justify-center bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900"
      initial={{ opacity: 0 }}
      animate={{ opacity: isActive ? 1 : 0.3 }}
    >
      <div className="text-center text-white z-10 max-w-4xl px-8">
        <motion.h1
          className="text-6xl md:text-8xl font-bold mb-6"
          initial={{ y: 100, opacity: 0 }}
          animate={{ y: isActive ? 0 : 100, opacity: isActive ? 1 : 0 }}
          transition={{ delay: 0.2 }}
        >
          {panel.title}
        </motion.h1>
        <motion.p
          className="text-xl md:text-2xl opacity-90"
          initial={{ y: 50, opacity: 0 }}
          animate={{ y: isActive ? 0 : 50, opacity: isActive ? 1 : 0 }}
          transition={{ delay: 0.4 }}
        >
          {panel.subtitle}
        </motion.p>

        {/* Progress indicator */}
        <motion.div
          className="mt-12 w-96 h-1 bg-white/20 mx-auto rounded-full"
          initial={{ scaleX: 0 }}
          animate={{ scaleX: isActive ? progress : 0 }}
        >
          <div
            className="h-full bg-white rounded-full transition-all duration-500"
            style={{ width: `${progress * 100}%` }}
          />
        </motion.div>
      </div>

      {/* Background animation elements */}
      <motion.div
        className="absolute inset-0 opacity-20"
        animate={{ rotate: isActive ? 360 : 0 }}
        transition={{ duration: 20, repeat: Infinity, ease: "linear" }}
      >
        {/* Geometric patterns or particle effects */}
      </motion.div>
    </motion.div>
  );
};
```

```typescript
// src/components/StorytellingPage/panels/ProblemPanel.tsx
const ProblemPanel: React.FC<StoryPanelProps> = ({ panel, isActive, progress }) => {
  const problemData = panel.extraProps?.problemData as A2AStoryContent['problem'];

  return (
    <div className="min-h-screen bg-red-50 py-20">
      <div className="max-w-6xl mx-auto px-8">
        <motion.h2
          className="text-5xl font-bold text-gray-900 mb-12 text-center"
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: isActive ? 1 : 0.3, y: isActive ? 0 : 50 }}
        >
          {problemData?.title || panel.title}
        </motion.h2>

        <div className="grid md:grid-cols-2 gap-12">
          {/* Pain points visualization */}
          <div className="space-y-6">
            {problemData?.painPoints.map((point, index) => (
              <motion.div
                key={index}
                className="bg-white p-6 rounded-lg shadow-lg border-l-4 border-red-500"
                initial={{ opacity: 0, x: -50 }}
                animate={{
                  opacity: (isActive && progress > index * 0.2) ? 1 : 0.3,
                  x: (isActive && progress > index * 0.2) ? 0 : -50
                }}
                transition={{ delay: index * 0.1 }}
              >
                <p className="text-gray-800 text-lg">{point}</p>
              </motion.div>
            ))}
          </div>

          {/* Statistics or infographics */}
          <div className="flex items-center justify-center">
            <motion.div
              className="text-center"
              animate={{ scale: isActive ? 1 : 0.8, opacity: isActive ? 1 : 0.3 }}
            >
              {/* Interactive problem visualization */}
            </motion.div>
          </div>
        </div>
      </div>
    </div>
  );
};
```

```typescript
// src/components/StorytellingPage/panels/PhasePanel.tsx
const PhasePanel: React.FC<StoryPanelProps> = ({ panel, isActive, progress }) => {
  const phaseNumber = panel.phase || 1;
  const phaseData = panel.extraProps?.phaseData as A2AStoryContent['phases'][1];

  return (
    <div className={`min-h-screen py-20 ${getPhaseBackground(phaseNumber)}`}>
      <div className="max-w-6xl mx-auto px-8">
        {/* Phase indicator */}
        <motion.div
          className="text-center mb-12"
          initial={{ opacity: 0 }}
          animate={{ opacity: isActive ? 1 : 0.3 }}
        >
          <div className="flex justify-center items-center space-x-4 mb-8">
            {[1, 2, 3].map((phase) => (
              <div
                key={phase}
                className={cn(
                  "w-12 h-12 rounded-full flex items-center justify-center font-bold",
                  phase <= phaseNumber
                    ? "bg-blue-600 text-white"
                    : "bg-gray-300 text-gray-600"
                )}
              >
                {phase}
              </div>
            ))}
          </div>
          <h2 className="text-4xl font-bold text-gray-900">
            Phase {phaseNumber}: {phaseData?.title}
          </h2>
        </motion.div>

        {/* Phase content with progressive disclosure */}
        <div className="grid md:grid-cols-2 gap-12">
          <motion.div
            initial={{ opacity: 0, x: -50 }}
            animate={{ opacity: isActive ? 1 : 0.3, x: isActive ? 0 : -50 }}
          >
            <h3 className="text-2xl font-semibold mb-6">Key Features</h3>
            <div className="space-y-4">
              {phaseData?.keyFeatures.map((feature, index) => (
                <motion.div
                  key={index}
                  className="bg-white p-4 rounded-lg shadow"
                  initial={{ opacity: 0 }}
                  animate={{
                    opacity: (isActive && progress > index * 0.25) ? 1 : 0.3
                  }}
                  transition={{ delay: index * 0.2 }}
                >
                  {feature}
                </motion.div>
              ))}
            </div>
          </motion.div>

          <motion.div
            initial={{ opacity: 0, x: 50 }}
            animate={{ opacity: isActive ? 1 : 0.3, x: isActive ? 0 : 50 }}
          >
            {/* Phase visualization or diagram */}
            <PhaseVisualization phase={phaseNumber} progress={progress} />
          </motion.div>
        </div>
      </div>
    </div>
  );
};
```

### 3. StorytellingPage 메인 컴포넌트 재구성

```typescript
// src/components/StorytellingPage/index.tsx
export function StorytellingPage({ agentStyle }: StorytellingPageProps) {
  const { scenarios } = useScenario();

  // A2A 스토리 콘텐츠 정의
  const storyPanels: StoryPanel[] = useMemo(() => {
    const panels: StoryPanel[] = [];

    // Hero Section (0-10%)
    panels.push({
      id: 'hero',
      type: 'hero',
      title: 'A2A Future',
      subtitle: 'Revolutionizing Communication Through Intelligent Agents',
      component: HeroPanel,
      scrollRange: [0, 0.1],
      extraProps: {
        backgroundVideo: '/assets/hero-background.mp4'
      }
    });

    // Problem Section (10-25%)
    panels.push({
      id: 'problem',
      type: 'problem',
      title: 'The Communication Challenge',
      component: ProblemPanel,
      scrollRange: [0.1, 0.25],
      extraProps: {
        problemData: {
          title: 'Fragmented Digital Experiences',
          painPoints: [
            '복잡한 멀티 플랫폼 사용자 경험',
            '반복적인 정보 입력 및 인증 과정',
            '서비스 간 연동 부족으로 인한 효율성 저하',
            '개인화된 서비스 제공의 한계'
          ],
          statistics: [
            { label: '평균 앱 전환', value: '11회/일', description: '사용자당 일일 앱 전환 횟수' },
            { label: '중복 정보 입력', value: '40%', description: '동일 정보 재입력 비율' }
          ]
        }
      }
    });

    // Solution Section (25-40%)
    panels.push({
      id: 'solution',
      type: 'solution',
      title: 'A2A: The Intelligent Solution',
      component: SolutionPanel,
      scrollRange: [0.25, 0.4],
      extraProps: {
        solutionData: {
          title: 'Agent-to-Agent Communication',
          approach: '지능형 에이전트들이 사용자를 대신하여 직접 소통하고 협상하는 새로운 패러다임',
          benefits: [
            '사용자 경험의 완전한 자동화',
            '개인화된 서비스 제공',
            '효율적인 리소스 활용',
            '새로운 비즈니스 모델 창출'
          ]
        }
      }
    });

    // Phase Evolution (40-70%)
    [1, 2, 3].forEach((phase, index) => {
      panels.push({
        id: `phase-${phase}`,
        type: 'phase',
        title: `Phase ${phase}`,
        component: PhasePanel,
        phase: phase as 1 | 2 | 3,
        scrollRange: [0.4 + index * 0.1, 0.5 + index * 0.1],
        extraProps: {
          phaseData: getPhaseData(phase)
        }
      });
    });

    // Demo Scenarios (70-90%)
    const scenarioKeys = Object.keys(scenarios || {});
    scenarioKeys.forEach((scenarioId, index) => {
      const scenario = scenarios?.[scenarioId];
      if (scenario) {
        panels.push({
          id: `scenario-${scenarioId}`,
          type: 'scenario',
          title: scenario.title,
          description: scenario.description,
          component: ScenarioPanel,
          scrollRange: [0.7 + index * 0.05, 0.75 + index * 0.05],
          steps: scenario.steps,
          scenarioId,
          extraProps: {
            demoType: 'focused',
            scenario
          }
        });
      }
    });

    // Call-to-Action (90-100%)
    panels.push({
      id: 'cta',
      type: 'cta',
      title: 'Join the A2A Revolution',
      component: CTAPanel,
      scrollRange: [0.9, 1],
      extraProps: {
        ctaData: {
          title: 'Ready to Transform Your Business?',
          subtitle: 'A2A 생태계에 참여하여 새로운 기회를 발견하세요',
          actions: [
            { label: 'Partner Program', link: '/partners' },
            { label: 'Developer APIs', link: '/developers' },
            { label: 'Contact Sales', link: '/contact' }
          ]
        }
      }
    });

    return panels;
  }, [scenarios]);

  const {
    currentPanel,
    currentPanelProgress,
    previewStepIndex,
    previewTotalSteps,
    setBindScrollToProgress
  } = useScrollProgress(storyPanels);

  useEffect(() => {
    setBindScrollToProgress(true);
    return () => setBindScrollToProgress(false);
  }, [setBindScrollToProgress]);

  return (
    <div className="storytelling-container" style={{ height: `${storyPanels.length * 100}vh` }}>
      <ScrollProgressIndicator
        panels={storyPanels}
        currentPanelId={currentPanel?.id}
        previewStepIndex={previewStepIndex}
        previewTotalSteps={previewTotalSteps}
      />

      {storyPanels.map((panel) => (
        <PanelContainer
          key={panel.id}
          panel={panel}
          isActive={currentPanel?.id === panel.id}
          progress={currentPanel?.id === panel.id ? currentPanelProgress : 0}
          agentStyle={agentStyle}
          style={{
            position: 'absolute',
            top: `${panel.scrollRange[0] * storyPanels.length * 100}vh`,
            height: `${(panel.scrollRange[1] - panel.scrollRange[0]) * storyPanels.length * 100}vh`
          }}
        />
      ))}
    </div>
  );
}
```

### 4. 유틸리티 함수 및 데이터 생성

```typescript
// src/utils/a2aStoryData.ts
export const getPhaseData = (
  phase: 1 | 2 | 3
): A2AStoryContent['phases'][1] => {
  const phaseDataMap = {
    1: {
      title: 'A2H (Agent to Human)',
      description:
        '고객의 AI 에이전트가 전화와 SMS를 통해 인간 서비스 제공자와 직접 상호작용',
      keyFeatures: [
        '음성 통화 기반 예약 및 주문',
        'SMS 폴백으로 간단한 응답 처리',
        '기본적인 맥락 이해 및 대화',
        '사람 중심의 서비스 프로세스',
      ],
      scenarios: ['phase1_scenario1_1', 'phase1_scenario1_2'],
    },
    2: {
      title: 'Lite Agent (Semi-automation)',
      description: '앱 기반 Lite Agent가 인간을 보조하며 파트너 서비스와 연동',
      keyFeatures: [
        'A.Biz 앱을 통한 비즈니스 정보 관리',
        'CatchTable 등 기존 플랫폼 연동',
        'Amazon 콘텐츠 및 상품 추천',
        '반자동화된 예약 및 주문 처리',
      ],
      scenarios: [
        'phase2_scenario2_1',
        'phase2_scenario2_2',
        'phase2_scenario2_3',
      ],
    },
    3: {
      title: 'Full A2A (Agent to Agent)',
      description:
        '완전한 에이전트 간 직접 소통 및 협상으로 hyper-personalized 경험 제공',
      keyFeatures: [
        '에이전트 간 직접 협상 및 거래',
        '과거 데이터 기반 개인화',
        '자동화된 loyalty 관리',
        '통합된 end-to-end 경험',
      ],
      scenarios: [
        'phase3_scenario3_1',
        'phase3_scenario3_2',
        'phase3_scenario3_3',
        'phase3_scenario3_4',
      ],
    },
  };

  return phaseDataMap[phase];
};

export const getPhaseBackground = (phase: 1 | 2 | 3): string => {
  const backgrounds = {
    1: 'bg-gradient-to-br from-green-50 to-emerald-100',
    2: 'bg-gradient-to-br from-yellow-50 to-orange-100',
    3: 'bg-gradient-to-br from-purple-50 to-indigo-100',
  };
  return backgrounds[phase];
};
```

## 재사용 가능한 연관 코드

### 기존 활용 가능한 컴포넌트 및 시스템

1. **StoryPanel 타입 시스템** (`src/types/storytelling.ts`)
   - 기존 인터페이스 확장하여 새로운 패널 타입 지원
   - extraProps 시스템으로 패널별 커스텀 데이터 전달

2. **PanelContainer** (`src/components/StorytellingPage/PanelContainer.tsx`)
   - 범용 패널 래퍼로 모든 새로운 패널 타입에서 재사용
   - prop spreading 시스템으로 확장성 보장

3. **useScrollProgress 훅** (`src/hooks/useScrollProgress.ts`)
   - 기존 스크롤 진행률 계산 로직 그대로 활용
   - 새로운 패널 배열에 대해서도 동일하게 동작

4. **DemoView 섹션 컴포넌트들** (`src/components/DemoView/`)
   - CustomerSection, AgentSection, ServerSection을 ScenarioPanel에서 재사용
   - 기존 3-pillar 레이아웃을 시나리오별 데모에 활용

5. **시나리오 데이터 시스템** (`src/data/scenarios.json`, `src/hooks/useScenario.ts`)
   - 기존 시나리오 데이터를 각 Phase별 데모에서 활용
   - useScenario 훅으로 동적 시나리오 로딩

### 새로 생성할 컴포넌트

```typescript
// 파일 구조
src/components/StorytellingPage/panels/
├── HeroPanel.tsx          // 새로 생성
├── ProblemPanel.tsx       // 새로 생성
├── SolutionPanel.tsx      // 새로 생성
├── PhasePanel.tsx         // 새로 생성
├── ScenarioPanel.tsx      // 새로 생성
├── CTAPanel.tsx           // 새로 생성
├── IntroPanel.tsx         // 기존 (필요시 수정)
├── DemoPanel.tsx          // 기존 (ScenarioPanel과 통합)
└── SummaryPanel.tsx       // 기존 (CTAPanel로 대체)

src/utils/
├── a2aStoryData.ts        // 새로 생성
└── panelAnimations.ts     // 새로 생성 (애니메이션 유틸)

src/types/
└── storytelling.ts        // 기존 확장
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 추가 필요

1. **새로운 패널 컴포넌트들**

```typescript
// tests/components/StorytellingPage/panels/HeroPanel.test.tsx
describe('HeroPanel', () => {
  it('should render hero content correctly', () => {
    // Hero 패널의 제목, 부제목 렌더링 확인
  });

  it('should animate based on isActive prop', () => {
    // isActive 상태에 따른 애니메이션 동작 확인
  });

  it('should update progress indicator', () => {
    // progress prop에 따른 진행률 표시 확인
  });
});

// 각 패널 타입별로 동일한 패턴으로 테스트 작성
```

2. **getPhaseData 유틸리티 함수**

```typescript
// tests/utils/a2aStoryData.test.ts
describe('getPhaseData', () => {
  it('should return correct data for each phase', () => {
    // Phase 1, 2, 3 각각에 대한 올바른 데이터 반환 확인
  });

  it('should include all required fields', () => {
    // title, description, keyFeatures, scenarios 필드 존재 확인
  });
});
```

### 통합 테스트 수정 필요

1. **StorytellingPage 컴포넌트**

```typescript
// tests/components/StorytellingPage/index.test.tsx
describe('StorytellingPage with A2A content', () => {
  it('should render all 6 main sections', () => {
    // Hero, Problem, Solution, Phase, Scenario, CTA 섹션 렌더링 확인
  });

  it('should generate panels from scenarios data', () => {
    // scenarios.json 데이터를 기반으로 동적 패널 생성 확인
  });

  it('should handle scroll progress correctly', () => {
    // 스크롤 진행률에 따른 패널 활성화 및 전환 확인
  });
});
```

### E2E 테스트 추가

```typescript
// e2e/storytelling-flow.spec.ts
describe('A2A Storytelling Flow', () => {
  it('should complete full storytelling journey', () => {
    // 전체 스크롤 플로우를 통한 사용자 여정 테스트
  });

  it('should maintain smooth scroll performance', () => {
    // 60fps 애니메이션 및 성능 확인
  });

  it('should be accessible with keyboard navigation', () => {
    // 키보드 네비게이션 및 스크린 리더 지원 확인
  });
});
```

## 구현 단계별 우선순위

### Phase 1: 기반 구조 설정 (1-2일)

1. StoryPanel 타입 확장 및 새로운 패널 타입 정의
2. A2A 스토리 데이터 구조 설계 및 getPhaseData 유틸리티 구현
3. 기본 패널 컴포넌트 스켈레톤 생성

### Phase 2: 핵심 패널 구현 (2-3일)

1. HeroPanel, ProblemPanel, SolutionPanel 구현
2. PhasePanel 및 Phase 진화 시각화 구현
3. 기존 DemoPanel을 ScenarioPanel로 확장

### Phase 3: 통합 및 최적화 (2-3일)

1. CTAPanel 구현 및 전체 스토리 플로우 통합
2. 애니메이션 최적화 및 성능 튜닝
3. 반응형 디자인 및 접근성 구현

### Phase 4: 테스트 및 검증 (1-2일)

1. 단위 테스트 및 통합 테스트 구현
2. E2E 테스트 및 성능 검증
3. 최종 폴리시 및 버그 수정

## 주의 사항

- **성능**: 대용량 스크롤 콘텐츠로 인한 메모리 사용량 모니터링 필요
- **호환성**: 기존 DemoView 모드와의 완전한 분리 및 독립성 보장
- **확장성**: 향후 새로운 시나리오 추가 시 최소한의 코드 변경으로 지원 가능하도록 설계
- **접근성**: 스크롤 기반 인터랙션에 대한 대체 네비게이션 방법 제공
- **데이터 연동**: scenarios.json 구조 변경 시 자동 적응 가능한 robust한 파싱 로직 구현
