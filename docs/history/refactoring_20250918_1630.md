# ReasoningAgentSection 리팩토링 계획

## 작업의 목적

기존 `TerminalSection`을 대체할 수 있는 `ReasoningAgentSection` 컴포넌트를 구현하여, AI Agent의 **추론 과정을 강조**하고 **Action은 간소화**한 새로운 시각화 방식을 제공한다. 이를 통해 사용자는 AI Agent가 **왜 그런 행동을 선택했는지**에 대한 의사결정 과정을 명확하게 이해할 수 있게 된다.

## 현재의 상태 / 문제점

### 1. TerminalSection의 현재 구조

- **데이터 흐름**: `scenario.tsx`의 `AgenticStep[]`을 필터링하여 특정 Agent의 액션만 표시
- **시각화 방식**: 터미널 스타일로 액션의 **구체적 내용**에 집중 (메시지 내용, API 호출 상세 등)
- **Props 인터페이스**: `entity`, `label`, `labelColor`, `sectionClass`, `steps?`, `entityName?`, `isActive?`, `variant?`
- **핵심 로직**: `LogicCard` 컴포넌트를 통해 각 `AgenticStep`을 카드 형태로 표시

### 2. 기존 데이터 구조의 한계

- `AgenticStep`의 `reason` 필드가 AI의 추론 과정을 담고 있지만 시각적으로 강조되지 않음
- 액션의 구체적 내용(`content`, `request`, `response` 등)이 주요 정보로 표시되어 추론 과정이 부차적으로 처리됨
- 시퀀스 다이어그램 스타일의 **입력→추론→출력** 흐름이 명확하지 않음

### 3. 시나리오 데이터 구조 분석

```typescript
// scenarios.json에서 reason 필드 사용 현황
{
  "type": "send-message",
  "action": {
    "reason": "고객의 예약 요청에 따라, 프로필과 과거 선호도를 기반으로..."
  }
}
```

- `reason` 필드에 AI의 추론 과정이 자연어로 기록되어 있음
- 하지만 구조화되지 않아 **상황 분석**, **전략 수립**, **행동 결정** 등의 단계별 분리가 어려움

## 추가 분석 과제

1. **추론 과정 구조화 방법론 검토**
   - 현재 `reason` 필드의 자연어 텍스트를 어떻게 **구조화된 추론 단계**로 변환할 것인가?
   - 입력 정보, 상황 분석, 전략 수립, 행동 결정의 4단계 구조가 적절한가?

2. **기존 시나리오 데이터와의 호환성**
   - 새로운 추론 중심 데이터 구조를 도입하면서도 기존 `scenarios.json` 데이터를 활용할 수 있는 변환 로직이 필요
   - 어떤 `AgenticStep` 타입들을 어떻게 입력/추론/출력으로 분류할 것인가?

3. **TerminalSection과의 Swap 메커니즘**
   - 동일한 Props 인터페이스를 유지하면서 어떻게 다른 시각화를 제공할 것인가?
   - `variant` prop을 활용하여 `reasoning` 모드를 추가할 것인가, 아니면 별도 컴포넌트로 분리할 것인가?

## 변경 이후의 상태 / 해결 판정 기준

### 1. 기능적 목표

- [✅] `TerminalSection`과 동일한 Props 인터페이스로 **완전히 교체 가능**
- [✅] 기존 `AgenticStep[]` 데이터를 입력받아 **추론 중심** 시각화 제공
- [✅] shadcn/ui 디자인 시스템에 맞는 **미니멀하고 세련된** UI 구현
- [✅] **입력→추론→출력** 시퀀스 다이어그램 스타일 플로우 표시

### 2. 시각적 목표

- [✅] 추론 내용이 **70% 이상의 시각적 비중**을 차지
- [✅] Action 유형은 **아이콘+라벨** 형태로 간소화 (구체적 내용 제거)
- [✅] **펄스 애니메이션**으로 현재 진행 중인 추론 단계 강조
- [✅] **연결선과 마커**로 시간 흐름과 인과관계 명확화

### 3. 성능 목표

- [✅] 기존 `TerminalSection`과 동일한 **렌더링 성능** 유지
- [✅] **실시간 스크롤** 및 **애니메이션** 기능 지원
- [✅] **타입 안전성** 보장

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 새로운 타입 정의 파일 생성

**파일**: `src/types/reasoning.ts`

```typescript
// 추론 단계 타입 정의
export type ReasoningStepType = 'input' | 'reasoning' | 'output';

// 구조화된 추론 내용
export interface ReasoningContent {
  situation?: string; // 현재 상황 분석
  requiredInfo?: string[]; // 필요한 정보
  strategy?: string; // 최적 전략
  evaluation?: string[]; // 평가 기준
  decision?: string; // 최종 결정
}

// 추론 중심 스텝 인터페이스
export interface ReasoningStep {
  id: string;
  type: ReasoningStepType;
  timestamp: number;

  // 입력/출력 단계용
  actionType?: string; // 'SMS', 'Call', 'API', 'Response' 등
  actionIcon?: string; // 이모지 아이콘

  // 추론 단계용
  title?: string; // 추론 단계 제목
  reasoning?: ReasoningContent; // 구조화된 추론 내용

  // 원본 데이터 참조
  originalStep?: AgenticStep;
}
```

### 2. 데이터 변환 유틸리티 함수

**파일**: `src/utils/reasoningTransform.ts`

```typescript
import type { AgenticStep } from '@/contexts/scenario';
import type { ReasoningStep, ReasoningStepType } from '@/types/reasoning';

// AgenticStep을 ReasoningStep으로 변환
export function transformToReasoningSteps(
  steps: AgenticStep[]
): ReasoningStep[] {
  const reasoningSteps: ReasoningStep[] = [];

  steps.forEach((step, index) => {
    // 1. 입력 단계 생성 (from이 Agent가 아닌 경우)
    if (step.action.from !== 'customer_agent') {
      reasoningSteps.push({
        id: `input-${step.action.timestamp}`,
        type: 'input',
        timestamp: step.action.timestamp,
        actionType: getActionType(step),
        actionIcon: getActionIcon(step),
        originalStep: step,
      });
    }

    // 2. 추론 단계 생성 (reason이 있는 경우)
    if (step.action.reason) {
      reasoningSteps.push({
        id: `reasoning-${step.action.timestamp}`,
        type: 'reasoning',
        timestamp: step.action.timestamp + 1,
        title: generateReasoningTitle(step),
        reasoning: parseReasoningContent(step.action.reason),
        originalStep: step,
      });
    }

    // 3. 출력 단계 생성 (Agent가 수행하는 액션)
    if (step.action.from === 'customer_agent') {
      reasoningSteps.push({
        id: `output-${step.action.timestamp}`,
        type: 'output',
        timestamp: step.action.timestamp + 2,
        actionType: getActionType(step),
        actionIcon: getActionIcon(step),
        originalStep: step,
      });
    }
  });

  return reasoningSteps.sort((a, b) => a.timestamp - b.timestamp);
}
```

### 3. ReasoningAgentSection 컴포넌트

**파일**: `src/components/shared/ReasoningAgentSection/index.tsx`

```typescript
interface ReasoningAgentSectionProps {
  entity: ServerState | null;
  label: string;
  labelColor: string;
  sectionClass: string;
  steps?: AgenticStep[];
  entityName?: string;
  isActive?: boolean;
  variant?: 'minimal' | 'formal' | 'hacker' | 'reasoning';
}

export function ReasoningAgentSection({
  entity,
  label,
  labelColor,
  sectionClass,
  steps: externalSteps,
  entityName,
  isActive: externalIsActive = false,
  variant = 'reasoning',
}: ReasoningAgentSectionProps) {
  // TerminalSection과 동일한 데이터 로직
  const { state: scenarioState } = useScenario();
  const state = useMemo(
    () => (externalSteps ? { steps: externalSteps } : scenarioState),
    [externalSteps, scenarioState]
  );

  // AgenticStep을 ReasoningStep으로 변환
  const reasoningSteps = useMemo(() => {
    const agentSteps = state.steps.filter(
      (s: AgenticStep) =>
        s.action.from === (entityName || entity?.name) ||
        s.action.to === (entityName || entity?.name)
    );
    return transformToReasoningSteps(agentSteps);
  }, [state.steps, entity, entityName]);

  return (
    <motion.div className={cn(sectionClass, 'reasoning-container')}>
      {/* Header - shadcn/ui 스타일 */}
      <div className="agent-header">
        <div className="agent-icon">🤖</div>
        <div>
          <h3 className="agent-title">{label}</h3>
          <p className="agent-subtitle">Decision Process Visualization</p>
        </div>
      </div>

      {/* Reasoning Flow */}
      <div className="reasoning-flow">
        <AnimatePresence>
          {reasoningSteps.map((step, index) => (
            <ReasoningStepComponent
              key={step.id}
              step={step}
              isActive={isActive && index === reasoningSteps.length - 1}
            />
          ))}
        </AnimatePresence>
      </div>
    </motion.div>
  );
}
```

## 재사용 가능한 연관 코드

### 1. 기존 컴포넌트 재사용

- **LogicCard**: 추론 내용 표시를 위한 카드 UI 컴포넌트 (`src/components/shared/LogicCard`)
- **SectionLabel**: 섹션 헤더 라벨 컴포넌트 (`src/components/shared/SectionLabel`)
- **애니메이션 로직**: `TerminalSection`의 스크롤 및 펄스 애니메이션 로직 재사용

### 2. Hooks 재사용

- **useScenario**: 시나리오 상태 관리 (`src/hooks/useScenario.ts`)
- **스크롤 관리**: `TerminalSection`의 auto-scroll 로직 활용

### 3. 스타일링 시스템

- **TailwindCSS**: shadcn/ui 디자인 토큰 활용
- **framer-motion**: 기존 애니메이션 패턴 재사용
- **CSS 변수**: `src/index.css`의 색상 시스템 활용

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. 단위 테스트

```typescript
// src/utils/__tests__/reasoningTransform.test.ts
describe('reasoningTransform', () => {
  test('AgenticStep을 ReasoningStep으로 올바르게 변환', () => {
    // reason이 있는 step의 경우 input-reasoning-output 순서로 변환되는지 확인
  });

  test('Action 타입별 아이콘 매핑 검증', () => {
    // send-message → SMS, make-call → Call 등 매핑 확인
  });
});
```

### 2. 컴포넌트 테스트

```typescript
// src/components/shared/ReasoningAgentSection/__tests__/index.test.tsx
describe('ReasoningAgentSection', () => {
  test('TerminalSection과 동일한 Props로 렌더링', () => {
    // 기존 TerminalSection Props로 정상 렌더링되는지 확인
  });

  test('추론 단계별 시각적 구분 확인', () => {
    // input/reasoning/output 단계가 올바른 스타일로 표시되는지 확인
  });
});
```

### 3. 통합 테스트

```typescript
// src/components/DemoView/__tests__/reasoning-integration.test.tsx
describe('ReasoningAgentSection Integration', () => {
  test('AgentSection에서 TerminalSection 대신 사용 가능', () => {
    // AgentSection에서 variant="reasoning" 시 정상 작동 확인
  });
});
```

---

**작업 우선순위:**

1. 타입 정의 및 변환 로직 구현 (높음)
2. 기본 ReasoningAgentSection 컴포넌트 구현 (높음)
3. shadcn/ui 스타일링 적용 (중간)
4. 애니메이션 및 인터랙션 구현 (중간)
5. 테스트 코드 작성 (낮음)

**예상 작업 기간:** 2-3일
