# Refactoring Plan: useScenarioControl.ts를 ScenarioContext로 병합

## 작업의 목적

`useScenarioControl.ts`의 시나리오 선택, progress 관리, 시나리오 실행 로직을 `scenario.tsx`의 ScenarioContext로 통합하여 단일 상태 관리 체계를 구축한다. 이를 통해:

1. **단일 진실 공급원(Single Source of Truth)**: 모든 시나리오 관련 상태를 ScenarioContext에서 관리
2. **중복 제거**: useScenarioControl과 ScenarioContext 간 중복 상태 제거
3. **의존성 단순화**: 복잡한 hook 체인(useScenarioControl → useScenario → ScenarioContext) 제거
4. **공유 상태 보장**: progress 상태를 컨텍스트에 포함하여 모든 하위 컴포넌트가 동일한 상태 참조

## 현재의 상태 / 문제점

### 현재 아키텍처 구조

```
useScenarioControl.ts
├── 시나리오 선택 (currentIndex, scenarios[])
├── progress 상태 관리
├── 시나리오 실행 로직 (handleStep, progress 변경 감지)
└── useScenario() hook 사용 (ScenarioContext 의존)

scenario.tsx (ScenarioContext)
├── 시나리오 상태 관리 (state, active)
├── 액션 함수들 (sendMessage, makeCall 등)
└── reset 함수
```

### 문제점

1. **중복 상태 관리**: 시나리오 선택과 progress가 useScenarioControl에, 시나리오 상태가 ScenarioContext에 분산
2. **복잡한 의존 관계**: `useScenarioControl` → `useScenario` → `ScenarioContext` 체인
3. **상태 불일치 가능성**: progress 상태가 컨텍스트 외부에 있어 동기화 문제 발생 가능
4. **컴포넌트 복잡도 증가**: 여러 hook을 조합해서 사용해야 함

### 영향받는 컴포넌트들

- `PlayControls.tsx`: `useScenarioControl` 사용
- `ScenarioSelector.tsx`: `useScenarioControl` 사용 (추정)
- `Player.tsx`: `useScenarioControl` 사용

## 추가 분석 과제

1. **시나리오 데이터 구조 검증**: `scenarios.json`의 구조가 ScenarioContext에서 올바르게 로드되는지 확인
2. **컴포넌트 영향도 분석**: 실제로 어떤 컴포넌트들이 useScenarioControl을 사용하는지 전체 조사
3. **성능 영향 평가**: 컨텍스트 크기 증가로 인한 리렌더링 영향 분석
4. **테스트 케이스 검증**: 기존 기능이 정상 동작하는지 확인

## 변경 이후의 상태 / 해결 판정 기준

### 목표 아키텍처 구조

```
ScenarioContext (scenario.tsx)
├── 시나리오 선택 (currentIndex, scenarios[])
├── progress 상태 관리
├── 시나리오 실행 로직 (handleStep, progress 변경 감지)
├── 시나리오 상태 관리 (state, active)
├── 액션 함수들 (sendMessage, makeCall 등)
└── 통합된 reset 함수

useScenarioProgress.ts (신규)
└── 자동 재생 관련 로직 (Player 컴포넌트 전용)
```

### 해결 판정 기준

1. ✅ 모든 컴포넌트가 `useScenario()` hook만으로 필요한 기능 접근 가능
2. ✅ progress 상태가 컨텍스트에 포함되어 모든 컴포넌트가 동일한 값 참조
3. ✅ `useScenarioControl.ts` 파일 제거 가능
4. ✅ 빌드 및 기존 기능 정상 동작
5. ✅ Play/Pause/Reset 기능 정상 동작
6. ✅ 시나리오 선택 기능 정상 동작

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ScenarioContextType 인터페이스 확장

**파일**: `src/contexts/scenario.tsx`

```typescript
export interface ScenarioContextType {
  // 기존 필드들
  state: Scenario;
  active: { agent?: AIAgentState; server?: HumanState };
  reset: (scenario?: Scenario) => void;
  action: CommunicationAction;

  // 추가 필드들
  scenarios: Scenario[]; // 시나리오 목록
  currentScenario: Scenario; // 현재 선택된 시나리오
  progress: number; // 진행 상태
  setCurrent: (index: number) => void; // 시나리오 선택
  progressNext: () => void; // 다음 단계 진행
  resetProgress: () => void; // progress 리셋
}
```

### 2. ScenarioContextProvider 상태 및 로직 추가

**파일**: `src/contexts/scenario.tsx`

```typescript
function ScenarioContextProvider({ children }: ScenarioContextProviderProps) {
  // 기존 상태들...

  // 추가 상태들
  const [currentIndex, setCurrentIndex] = useState(0);
  const [progress, setProgress] = useState(0);

  // 시나리오 목록 로딩 (useScenarioControl.ts에서 이동)
  const scenarios: Scenario[] = useMemo(() => {
    return Object.values(scenariosData) as unknown as Scenario[];
  }, []);

  // 현재 시나리오 (useScenarioControl.ts에서 이동)
  const currentScenario: Scenario = useMemo(
    () => scenarios[currentIndex] || scenarios[0],
    [currentIndex, scenarios]
  );

  // 시나리오 선택 함수 (useScenarioControl.ts에서 이동)
  const setCurrent = useCallback(
    (index: number) => {
      if (index >= 0 && index < scenarios.length) {
        setCurrentIndex(index);
        setProgress(0); // 시나리오 변경 시 progress 리셋
      }
    },
    [scenarios.length]
  );

  // progress 제어 함수들 (useScenarioControl.ts에서 이동)
  const progressNext = useCallback(() => {
    setProgress((prev) => prev + 1);
  }, []);

  const resetProgress = useCallback(() => {
    setProgress(0);
  }, []);

  // handleStep 함수 (useScenarioControl.ts에서 이동)
  const handleStep = useCallback(
    (stepToExecute: AgenticStep) => {
      const id = createId();
      const timestamp = new Date().getMilliseconds();
      switch (stepToExecute.type) {
        case 'send-message':
          sendMessage({ message: { ...stepToExecute.action, id, timestamp } });
          break;
        // ... 다른 case들
      }
    },
    [sendMessage, makeCall, acceptCall, finishCall, apiCall, apiResponse]
  );

  // progress 변경 시 시나리오 실행 useEffect (useScenarioControl.ts에서 이동)
  useEffect(() => {
    if (currentScenario && progress < currentScenario.steps.length) {
      const stepToExecute = currentScenario.steps[progress];
      if (stepToExecute) {
        handleStep(stepToExecute);
      }
    }
  }, [progress, currentScenario, handleStep]);

  // 시나리오 변경 시 progress 리셋 useEffect (useScenarioControl.ts에서 이동)
  useEffect(() => {
    if (
      currentScenario &&
      currentScenarioRef.current?.id !== currentScenario.id
    ) {
      currentScenarioRef.current = currentScenario;
      reset(currentScenario);
      setProgress(0);
    }
  }, [currentScenario, reset]);

  // contextValue에 추가 필드들 포함
  const contextValue: ScenarioContextType = useMemo(() => {
    return {
      // 기존 필드들...
      state,
      active,
      reset,
      action,

      // 추가 필드들
      scenarios,
      currentScenario,
      progress,
      setCurrent,
      progressNext,
      resetProgress,
    };
  }, [
    // 기존 의존성들...
    state,
    active,
    reset,
    action,
    // 추가 의존성들
    scenarios,
    currentScenario,
    progress,
    setCurrent,
    progressNext,
    resetProgress,
  ]);
}
```

### 3. useScenarioProgress Hook 생성

**파일**: `src/hooks/useScenarioProgress.ts` (신규)

```typescript
import { useCallback, useEffect, useRef, useState } from 'react';
import { useScenario } from './useScenario';

interface UseScenarioProgressReturnType {
  isPlaying: boolean;
  startAutoPlay: (interval?: number) => void;
  stopAutoPlay: () => void;
  togglePlay: () => void;
}

export function useScenarioProgress(): UseScenarioProgressReturnType {
  const [isPlaying, setIsPlaying] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const { progressNext, progress, currentScenario } = useScenario();

  const startAutoPlay = useCallback(
    (interval = 1500) => {
      stopAutoPlay();
      timerRef.current = setInterval(
        () => {
          if (progress < currentScenario.steps.length - 1) {
            progressNext();
          } else {
            stopAutoPlay();
          }
        },
        Math.max(200, interval)
      );
    },
    [progress, currentScenario.steps.length, progressNext]
  );

  const stopAutoPlay = useCallback(() => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
    setIsPlaying(false);
  }, []);

  const togglePlay = useCallback(() => {
    if (isPlaying) {
      stopAutoPlay();
    } else {
      setIsPlaying(true);
      startAutoPlay();
    }
  }, [isPlaying, startAutoPlay, stopAutoPlay]);

  useEffect(() => stopAutoPlay, []);

  return { isPlaying, startAutoPlay, stopAutoPlay, togglePlay };
}
```

### 4. PlayControls 컴포넌트 업데이트

**파일**: `src/components/ControlHeader/PlayControls.tsx`

```typescript
// 변경 전
import { useScenarioControl } from '@/hooks/useScenarioControl';

// 변경 후
import { useScenario } from '@/hooks/useScenario';
import { useScenarioProgress } from '@/hooks/useScenarioProgress';

// 컴포넌트 내부
export function PlayControls({ interval = 1500 }: PlayControlsProps) {
  // 변경 전
  const { reset } = useScenarioControl();
  const [isPlaying, setIsPlaying] = useState(false);

  // 변경 후
  const { resetProgress } = useScenario();
  const { isPlaying, togglePlay, stopAutoPlay } = useScenarioProgress();

  const handleReset = () => {
    stopAutoPlay(); // 자동 재생 중지
    resetProgress();
  };

  // Player 컴포넌트 제거 (useScenarioProgress에서 자동 재생 처리)
  // {isPlaying && <Player interval={interval} />} 제거
}
```

### 5. Player 컴포넌트 업데이트

**파일**: `src/components/ControlHeader/player.tsx`

```typescript
// Player 컴포넌트는 더 이상 필요 없음 - useScenarioProgress로 대체
// 또는 최소한으로 간소화하여 useScenarioProgress에서 사용
```

## 재사용 가능한 연관 코드

### 주요 인터페이스 및 타입

- **ScenarioContextType**: `src/contexts/scenario.tsx:310-318`
- **UseScenarioControlReturnType**: `src/hooks/useScenarioControl.ts:10-18` (삭제 예정)
- **UseScenarioProgressReturnType**: 신규 hook 인터페이스

### 주요 함수 및 로직

- **handleStep**: 시나리오 단계 실행 로직
- **progressNext**: 다음 단계로 진행
- **setCurrent**: 시나리오 선택
- **resetProgress**: progress 초기화

### 연관 파일들

- `src/contexts/scenario.tsx`: 메인 컨텍스트
- `src/hooks/useScenario.ts`: 컨텍스트 사용 hook
- `src/hooks/useScenarioControl.ts`: 삭제 예정
- `src/components/ControlHeader/PlayControls.tsx`: 업데이트 필요
- `src/components/ControlHeader/ScenarioSelector.tsx`: 업데이트 필요 (추정)
- `src/components/ControlHeader/player.tsx`: 간소화 또는 삭제

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 추가

1. **ScenarioContext 테스트**

   ```typescript
   // src/__tests__/contexts/ScenarioContext.test.tsx
   describe('ScenarioContext', () => {
     it('should provide scenarios list', () => {
       /* ... */
     });
     it('should manage progress state', () => {
       /* ... */
     });
     it('should execute steps on progress change', () => {
       /* ... */
     });
   });
   ```

2. **useScenarioProgress 테스트**
   ```typescript
   // src/__tests__/hooks/useScenarioProgress.test.ts
   describe('useScenarioProgress', () => {
     it('should toggle play state', () => {
       /* ... */
     });
     it('should start/stop auto play', () => {
       /* ... */
     });
   });
   ```

### 통합 테스트

1. **PlayControls 통합 테스트**
   ```typescript
   // Play 버튼 클릭 시 progress가 증가하는지 확인
   // Reset 버튼 클릭 시 progress가 0으로 리셋되는지 확인
   ```

### 기존 테스트 수정 가이드

- `useScenarioControl`을 사용하는 기존 테스트들은 `useScenario`로 변경
- progress 관련 테스트는 컨텍스트 상태를 직접 테스트하도록 수정

### 테스트 실행 가이드

```bash
# 단위 테스트
npm test -- --testPathPattern=ScenarioContext
npm test -- --testPathPattern=useScenarioProgress

# 통합 테스트
npm test -- --testPathPattern=PlayControls
```

---

**작업 순서**:

1. ScenarioContextType 확장 및 ScenarioContextProvider 업데이트
2. useScenarioProgress hook 생성
3. PlayControls 컴포넌트 업데이트
4. 다른 연관 컴포넌트들 업데이트
5. useScenarioControl.ts 삭제
6. 테스트 추가 및 실행
7. 빌드 및 기능 검증</content>
   <parameter name="filePath">/home/fritzprix/my_works/a2a-demov/docs/history/refactoring_20250914_1510.md
