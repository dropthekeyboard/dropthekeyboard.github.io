# MessageBubble/VoiceBubble Avatar 표시 오류 수정 계획

## 작업의 목적

MessageBubble과 VoiceBubble 컴포넌트에서 메시지의 실제 sender(from/to) 정보와 관계없이 무조건 Phone 주인의 Avatar가 표시되는 문제를 해결하여, 각 메시지의 실제 발신자에 맞는 정확한 Avatar가 표시되도록 개선합니다.

## 현재의 상태 / 문제점

### 핵심 문제

- **MessageBubble**: 모든 메시지에 동일한 `entity` prop이 전달되어 메시지의 `from` 정보와 관계없이 동일한 Avatar 표시
- **VoiceBubble**: MessageBubble과 동일한 문제
- **VoiceScreen**: 헤더 Avatar도 동일한 entity 사용으로 부정확한 표시

### 문제 발생 원인

1. **Avatar 결정 로직의 우선순위 문제**

   ```typescript
   // avatarHelpers.ts의 getEntityAvatarProps 함수
   if (entity?.avatarUrl) {
     return entity.avatarUrl; // entity가 있으면 무조건 사용
   }
   // fallbackSenderType은 entity가 없을 때만 사용됨
   ```

2. **상위 컴포넌트에서 동일한 entity 전달**

   ```tsx
   // MessageScreen.tsx
   <MessageBubble
     entity={entity} // 모든 메시지에 동일한 entity 전달
     senderType={getComponentSenderType(msg.senderType)}
   />
   ```

3. **메시지의 from/to 정보 미활용**
   - 메시지 객체에는 `from`, `to` 정보가 있으나 Avatar 결정에 사용되지 않음
   - `isOwnMessage` 계산은 되지만 Avatar 선택에는 반영되지 않음

## 관련 코드의 통합 구조 (Birdeye View)

```text
src/
├── types/message.ts                     # Props 타입 정의
├── components/shared/
│   ├── Avatar/
│   │   └── avatarHelpers.ts            # Avatar 결정 로직 (핵심 수정)
│   ├── MessageBubble/index.tsx         # 메시지 버블 (수정 필요)
│   ├── VoiceBubble/index.tsx          # 음성 버블 (수정 필요)
│   ├── MessageScreen/index.tsx         # 메시지 화면 (Props 전달 수정)
│   ├── VoiceScreen/index.tsx          # 음성 화면 (Props 전달 수정)
│   └── HomeScreen/index.tsx           # 홈 화면 (영향도 확인 필요)
└── contexts/scenario.tsx               # Entity, Message 타입 정의
```

### 현재 데이터 흐름

```text
Message {from, to, senderType}
  ↓
MessageScreen {entity, ownerName}
  ↓
MessageBubble {entity, senderType}
  ↓
getEntityAvatarProps(entity, senderType)
  ↓
entity.avatarUrl (항상 동일) ← 문제 지점
```

### 개선된 데이터 흐름

```text
Message {from, to, senderType}
  ↓
MessageScreen {entity, ownerName}
  ↓
MessageBubble {entity, senderType, messageFrom, ownerName}
  ↓
getMessageAvatarProps(messageFrom, ownerName, entity, senderType)
  ↓
messageFrom === ownerName ? ownerAvatar : senderAvatar ← 개선 지점
```

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **정확한 Avatar 표시**: 메시지의 `from` 정보에 따라 올바른 Avatar 표시
   - `from === ownerName`: 사용자(phone 주인) Avatar
   - `from !== ownerName`: 상대방 또는 Agent Avatar

2. **기존 기능 호환성**: HomeScreen 등 다른 컴포넌트의 Avatar 표시 기능은 영향받지 않음

3. **타입 안전성**: TypeScript 컴파일 오류 없이 모든 타입 정의 정확

### 테스트 시나리오

```typescript
// 시나리오 1: 사용자가 보낸 메시지
{from: "user", to: "agent"} → 사용자 Avatar 표시

// 시나리오 2: Agent가 보낸 메시지
{from: "agent", to: "user"} → Agent Avatar 표시

// 시나리오 3: 서버/고객센터가 보낸 메시지
{from: "server", to: "user"} → 서버 Avatar 표시
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. avatarHelpers.ts - 새로운 함수 추가

```typescript
// 추가할 함수
export function getMessageAvatarProps(
  messageFrom: string,
  ownerName: string,
  entity?: Entity | null,
  fallbackSenderType?: 'user' | 'ai' | 'agent' | 'server-human'
) {
  // 메시지가 owner로부터 온 경우 - 사용자 Avatar 사용
  if (messageFrom === ownerName) {
    return getAvatarProps('user');
  }

  // 메시지가 다른 사람으로부터 온 경우
  // entity가 있고 avatarUrl이 있으면 entity의 Avatar 사용
  if (entity?.avatarUrl) {
    return {
      src: entity.avatarUrl,
      alt: entity.displayName || entity.name || 'Avatar',
      fallbackIcon: undefined,
    };
  }

  // entity가 없으면 senderType 기반으로 결정
  return getAvatarProps(fallbackSenderType);
}
```

### 2. types/message.ts - Props 확장

```typescript
export interface MessageBubbleProps {
  message: string;
  isOwnMessage: boolean;
  senderType?: 'user' | 'ai' | 'agent' | 'server-human';
  // ... 기존 props

  // 새로 추가할 optional props
  messageFrom?: string;
  ownerName?: string;
  entity?: any;
}

export interface VoiceBubbleProps {
  message: string;
  isOwnMessage: boolean;
  senderType?: 'user' | 'ai' | 'agent' | 'server-human';
  // ... 기존 props

  // 새로 추가할 optional props
  messageFrom?: string;
  ownerName?: string;
  entity?: any;
}
```

### 3. MessageBubble/index.tsx - Avatar 로직 수정

```typescript
// 기존 import에 추가
import { getMessageAvatarProps } from '@/components/shared/Avatar/avatarHelpers';

export function MessageBubble({
  message,
  isOwnMessage,
  senderType = 'user',
  // ... 기존 props
  messageFrom,
  ownerName,
  entity,
}: MessageBubbleProps) {
  return (
    // ... JSX 구조 동일

    {/* Avatar - 수정 부분 */}
    <Avatar
      {...(messageFrom && ownerName
        ? getMessageAvatarProps(messageFrom, ownerName, entity, senderType)
        : getEntityAvatarProps(entity, senderType) // fallback to 기존 로직
      )}
      size="md"
      className="flex-shrink-0"
    />

    // ... 나머지 JSX 동일
  );
}
```

### 4. MessageScreen/index.tsx - Props 전달 수정

```typescript
<MessageBubble
  message={msg.content}
  isOwnMessage={msg.from === ownerName}
  senderType={getComponentSenderType(msg.senderType)}
  timestamp={msg.timestamp}
  isRead={msg.to === 'user'}
  enableMarkdown={msg.senderType === 'agent' || msg.senderType === 'server'}
  entity={entity}
  // 새로 추가할 props
  messageFrom={msg.from}
  ownerName={ownerName}
/>
```

## 재사용 가능한 연관 코드

### 핵심 공통 모듈

- **`avatarHelpers.ts`**: Avatar 결정 로직의 중앙 집중 관리
  - `getAvatarProps()`: 기본 senderType 기반 Avatar 결정
  - `getEntityAvatarProps()`: Entity 기반 Avatar 결정 (기존)
  - `getMessageAvatarProps()`: 메시지 정보 기반 Avatar 결정 (신규)

### 타입 정의 모듈

- **`types/message.ts`**: 메시지 관련 Props 타입 정의
- **`contexts/scenario.tsx`**: Entity, Message 인터페이스 정의

### 활용 가능한 기존 로직

```typescript
// MessageScreen과 VoiceScreen에서 공통 사용
const getComponentSenderType = (
  senderType?: 'agent' | 'customer' | 'server'
) => {
  switch (senderType) {
    case 'agent':
      return 'ai';
    case 'customer':
      return 'user';
    case 'server':
      return 'server-human';
    default:
      return 'user';
  }
};
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 필요 영역

#### 1. avatarHelpers.ts 테스트

```typescript
// src/components/shared/Avatar/__tests__/avatarHelpers.test.ts
describe('getMessageAvatarProps', () => {
  it('should return user avatar when messageFrom equals ownerName', () => {
    const result = getMessageAvatarProps('user1', 'user1', mockEntity, 'ai');
    expect(result).toEqual(getAvatarProps('user'));
  });

  it('should return entity avatar when messageFrom differs from ownerName and entity has avatarUrl', () => {
    const mockEntity = { avatarUrl: 'test.png', displayName: 'Test' };
    const result = getMessageAvatarProps('agent1', 'user1', mockEntity, 'ai');
    expect(result.src).toBe('test.png');
  });

  it('should fallback to senderType avatar when no entity avatarUrl', () => {
    const result = getMessageAvatarProps('agent1', 'user1', null, 'ai');
    expect(result).toEqual(getAvatarProps('ai'));
  });
});
```

#### 2. 컴포넌트 통합 테스트

```typescript
// src/components/shared/MessageBubble/__tests__/MessageBubble.test.tsx
describe('MessageBubble Avatar Display', () => {
  it('should display user avatar for own messages', () => {
    render(
      <MessageBubble
        message="test"
        isOwnMessage={true}
        messageFrom="user1"
        ownerName="user1"
        senderType="user"
      />
    );
    // Avatar src 검증
  });

  it('should display agent avatar for agent messages', () => {
    const mockEntity = { avatarUrl: 'agent.png' };
    render(
      <MessageBubble
        message="test"
        isOwnMessage={false}
        messageFrom="agent1"
        ownerName="user1"
        entity={mockEntity}
        senderType="ai"
      />
    );
    // Avatar src 검증
  });
});
```

### 회귀 테스트 필요 영역

- **HomeScreen**: 기존 getEntityAvatarProps 사용 부분이 영향받지 않는지 확인
- **기타 Avatar 사용 컴포넌트**: 전체 Avatar 표시 기능의 일관성 확인

### 수동 테스트 시나리오

1. **메시지 화면**: 서로 다른 sender의 메시지가 올바른 Avatar로 표시되는지 확인
2. **음성 통화 화면**: 음성 메시지의 Avatar가 올바르게 표시되는지 확인
3. **테마 변경**: 다크/라이트 모드에서도 Avatar가 올바르게 표시되는지 확인

## 추가 분석 과제

### 1. Entity 관리 체계 개선 검토

- 현재 단일 entity 전달 방식의 한계 분석
- 메시지별 sender entity 매핑 체계 구축 가능성 검토

### 2. Avatar 캐싱 및 성능 최적화

- Avatar 이미지 로딩 성능 개선 방안
- 메모이제이션을 통한 Avatar props 계산 최적화

### 3. 확장성 고려사항

- 그룹 채팅 시나리오에서의 Avatar 표시 방안
- 커스텀 Avatar 업로드 기능 지원 가능성

## 구현 우선순위

1. **Phase 1**: avatarHelpers.ts 함수 추가 및 타입 확장
2. **Phase 2**: MessageBubble, VoiceBubble 컴포넌트 수정
3. **Phase 3**: MessageScreen, VoiceScreen Props 전달 수정
4. **Phase 4**: 테스트 코드 작성 및 검증
5. **Phase 5**: 회귀 테스트 및 최종 검증

이 계획을 통해 기존 코드의 안정성을 유지하면서도 정확한 Avatar 표시 기능을 구현할 수 있습니다.
