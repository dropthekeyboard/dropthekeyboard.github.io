# Refactoring Plan: GSAP 기반 스크롤리텔링 컴포넌트 재구축

## 1. 작업의 목적

기존 `src/components/Test/index.tsx`에 구현된 GSAP `ScrollTrigger` 기반 스크롤리텔링(Scrollytelling) 로직을 최신 `@gsap/react` 라이브러리의 `useGSAP` 훅을 사용하여 안정적이고 재사용 가능한 `StorytellingPage` 컴포넌트로 재구축한다. 이를 통해 코드의 복잡도를 낮추고, 유지보수성을 향상시키며, React 컴포넌트 패러다임에 더 잘 맞는 구조로 개선하는 것을 목표로 한다.

## 2. 현재의 상태 / 문제점

-   **중앙 집중식 로직**: 현재 `GSAPPinningDemoContent` 컴포넌트 내의 단일 `useLayoutEffect` 훅에서 모든 섹션의 `ScrollTrigger` 인스턴스를 생성하고 관리하고 있다. 이는 컴포넌트가 비대해지고 로직이 복잡해지는 원인이 된다.
-   **불안정한 Ref 관리**: `useRef` 배열(`sectionRefs`)을 수동으로 관리하여 각 섹션의 DOM 노드를 참조하고 있다. 이 방식은 섹션이 동적으로 변경될 때 타이밍 이슈나 `null` 참조 오류를 발생시킬 잠재적 위험이 있다.
-   **React 19 비최적화**: React 19+ 환경에서 권장되는 `@gsap/react`의 `useGSAP` 훅을 사용하지 않아, 애니메이션 인스턴스의 자동 정리(cleanup)나 컨텍스트 관리의 이점을 활용하지 못하고 있다.
-   **낮은 재사용성**: 현재 로직은 `Test` 컴포넌트에 강하게 결합되어 있어, 다른 페이지나 다른 종류의 콘텐츠로 스크롤리텔링 기능을 확장하기 어렵다.

## 3. 관련 코드의 통합 구조 (Birdeye View)

```
GSAPPinningDemo (Entry Point)
└── PinningProvider (Context)
    └── GSAPPinningDemoContent (Monolithic Component)
        ├── useRef<Array<HTMLDivElement | null>> (모든 섹션 Ref 수동 관리)
        ├── useLayoutEffect (모든 ScrollTrigger 중앙 생성/관리)
        │   └── ScrollTrigger.create(...)
        ├── sections.map(...) (각 슬라이드 및 시나리오 렌더링)
        └── usePinning (Context를 통해 상태 전파)
```

## 4. 변경 이후의 상태 / 해결 판정 기준

### 변경 이후 상태

-   `StorytellingPage`라는 재사용 가능한 컨테이너 컴포넌트가 생성된다.
-   `StorytellingPage`는 `Section`이라는 자식 컴포넌트를 받아 스크롤 애니메이션을 적용한다.
-   각 `Section` 컴포넌트는 `useGSAP` 훅을 사용하여 자신의 `ScrollTrigger` 로직을 독립적으로 관리한다. (캡슐화)
-   `useRef` 배열을 통한 수동 관리가 최소화되고, `useGSAP`의 `scope`를 활용하여 안정적인 DOM 참조가 이루어진다.

```
App
└── StorytellingPage (재사용 가능한 컨테이너)
    ├── sections.map(...)
    │   └── Section (독립적인 애니메이션 로직)
    │       ├── useRef (자신의 컨테이너만 참조)
    │       └── useGSAP (자신의 ScrollTrigger만 생성/관리)
    │           └── ScrollTrigger.create(...)
    └── (PinningProvider/usePinning은 필요 시 유지 또는 간소화)
```

### 해결 판정 기준

-   `StorytellingPage` 컴포넌트가 다양한 종류의 자식 컴포넌트(슬라이드, 시나리오 등)를 받아 정상적으로 스크롤 pinning 및 애니메이션을 구현할 수 있다.
-   스크롤 시 브라우저 콘솔에 관련 오류가 발생하지 않으며, 애니메이션이 부드럽게 동작한다.
-   기존 `Test` 컴포넌트를 `StorytellingPage`로 교체해도 동일한 기능이 문제없이 작동한다.
-   컴포넌트 언마운트 시 `ScrollTrigger` 인스턴스가 `useGSAP`에 의해 자동으로 정리되어 메모리 누수가 발생하지 않는다.

## 5. 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 신규 파일: `src/components/StorytellingPage/index.tsx`

`Section` 컴포넌트가 `children`으로 함수를 받을 수 있도록 하여(Render Props 패턴), 자식 컴포넌트가 `ScrollTrigger`의 동적인 상태(`isActive`, `isPinned`)에 접근할 수 있도록 수정합니다.

```typescript
import React, { useRef, useState } from 'react';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';
import { useGSAP } from '@gsap/react';
import { cn } from '@/lib/utils';

gsap.registerPlugin(ScrollTrigger, useGSAP);

// Section에 전달될 pinning 상태 타입
export interface SectionPinningState {
  isActive: boolean;
  isPinned: boolean;
}

interface SectionProps {
  // children을 함수로 받아 pinning 상태를 전달 (Render Props)
  children: (state: SectionPinningState) => React.ReactNode;
  pinned?: boolean;
  pinEnd?: string;
  className?: string;
}

const Section: React.FC<SectionProps> = ({ children, pinned = false, pinEnd = '+=100%', className }) => {
  const container = useRef<HTMLDivElement>(null);
  const [pinningState, setPinningState] = useState<SectionPinningState>({ isActive: false, isPinned: false });

  useGSAP(() => {
    if (!container.current) return;

    ScrollTrigger.create({
      trigger: container.current,
      start: 'top top',
      end: pinned ? pinEnd : 'bottom top',
      pin: pinned,
      pinSpacing: pinned,
      // onToggle: self => console.log("active:", self.isActive)
      onToggle: self => setPinningState({ isActive: self.isActive, isPinned: pinned && self.isActive }),
    });
  }, { scope: container, dependencies: [pinned, pinEnd] });

  return (
    <div ref={container} className={cn('w-full', className)}>
      {/* children 함수를 호출하여 state 전달 */}
      {children(pinningState)}
    </div>
  );
};

interface StorytellingPageProps {
  sections: {
    content: (state: SectionPinningState) => React.ReactNode;
    pinned?: boolean;
    pinEnd?: string;
    className?: string;
  }[];
}

export const StorytellingPage: React.FC<StorytellingPageProps> = ({ sections }) => {
  return (
    <div className="w-full">
      {sections.map((section, index) => (
        <Section key={index} pinned={section.pinned} pinEnd={section.pinEnd} className={section.className}>
          {section.content}
        </Section>
      ))}
    </div>
  );
};
```

### `DemoView` 통합 예시 (`App.tsx` 등에서 사용)

`StorytellingPage`를 사용할 때, `DemoView`를 포함하는 섹션은 `content`로 함수를 전달하여 `pinningState`를 `ScrollControls`에 연결합니다.

```typescript
import { StorytellingPage } from '@/components/StorytellingPage';
import { Slide001 } from '@/components/Slide';
import { DemoView } from '@/components/DemoView';
import { ScrollControls } from '@/components/ControlHeader/ScrollControls';
import { ScenarioContextProvider, ScenarioLoader } from '@/contexts/scenario'; // 가정

const storytellingSections = [
  {
    content: () => <Slide001 />,
    pinned: false,
    className: 'min-h-screen flex items-center justify-center',
  },
  {
    // DemoView를 포함하는 시나리오 섹션
    content: (pinningState) => (
      <ScenarioContextProvider>
        <ScenarioLoader initialScenarioId="some-scenario-id" />
        {/* Section의 pinningState를 ScrollControls에 직접 전달 */}
        <ScrollControls enabled={pinningState.isActive} pinnedState={pinningState} />
        <DemoView />
      </ScenarioContextProvider>
    ),
    pinned: true,
    pinEnd: '+=500vh',
    className: 'h-screen flex items-center justify-center',
  },
];

function App() {
  return (
    <main>
      <StorytellingPage sections={storytellingSections} />
    </main>
  );
}
```

## 6. 재사용 가능한 연관 코드

-   **`ScrollControls` (`src/components/ControlHeader/ScrollControls.tsx`)**: 이제 `StorytellingPage`의 `Section`으로부터 직접 `pinningState`를 주입받아 동작합니다. 이로써 `usePinning` 컨텍스트에 대한 의존성이 제거되거나 역할이 축소되어, 컴포넌트 간 결합도가 낮아집니다.
-   **`DemoView` (`src/components/DemoView/index.tsx`)**: `ScenarioContextProvider`와 `ScrollControls`와 함께 배치되어야 하는 기존 구조는 유지됩니다. 이 전체 그룹이 `StorytellingPage`의 `content` 함수 내에서 반환되어 `Section`의 자식으로 렌더링됩니다.
-   **Slide 컴포넌트 (`src/components/Slide/*.tsx`)**: 각 슬라이드의 내용은 그대로 재사용된다. `StorytellingPage`의 `sections` 배열에 content로 전달된다.
-   **`AnimatedSlide` (`src/components/shared/AnimatedSlide.tsx`)**: 섹션 진입 시 페이드인과 같은 개별 애니메이션 효과는 `Section` 컴포넌트 내부에서 조합하여 계속 사용할 수 있다.
-   **`PinningProvider` / `usePinning` (`src/contexts/pinning.tsx`)**: 현재 섹션의 활성화 상태를 전역적으로 추적하는 기능이 여전히 필요하다면, `Section` 컴포넌트의 `useGSAP` 내 `onToggle` 콜백과 연동하여 유지할 수 있다. 다만, 구조가 단순화되면서 필요성이 감소할 수 있으므로 재검토가 필요하다.

## 7. Test Code 추가 및 수정 필요 부분에 대한 가이드

-   **Storybook 테스트**: `StorytellingPage.stories.tsx` 파일을 생성하여 다양한 종류의 섹션(pinned, unpinned, 긴 콘텐츠, 짧은 콘텐츠 등)을 조합했을 때의 시각적 동작을 테스트한다.
-   **Visual Regression 테스트**: Chromatic과 같은 도구를 Storybook과 연동하여 스크롤 위치에 따른 스냅샷을 비교하고, pinning으로 인한 레이아웃 깨짐이 없는지 확인한다.
-   **Unit/Integration 테스트**: `usePinning`과 같은 관련 훅의 로직이 변경되거나 유지될 경우, `react-testing-library`를 사용하여 특정 스크롤 상태에서 컨텍스트 값이 올바르게 업데이트되는지 검증하는 테스트 코드를 작성/수정한다.

## 8. 추가 분석 과제

-   `usePinning` 컨텍스트의 필요성 재검토: 각 `Section`이 독립적으로 동작하게 되면서, 전역 상태로 pinning 상태를 관리할 필요가 있는지 분석한다. `ScrollProgressTracker`와 같은 UI 컴포넌트와의 연동을 위해서만 최소한으로 유지할지, 혹은 각 컴포넌트가 `ScrollTrigger`의 상태를 직접 구독하는 방식으로 변경할지 결정이 필요하다.
-   성능 최적화: 수십 개의 섹션이 동시에 렌더링될 경우의 성능을 분석한다. `React.lazy` 등을 활용하여 뷰포트 바깥의 컴포넌트를 지연 로딩하는 전략을 `StorytellingPage`에 통합할 수 있을지 검토한다.
