# Refactoring Plan: SlideGSAPSection as GSAPState Provider

## 작업의 목적

SlideGSAPSection이 직접 GSAPScrollContext Provider 역할을 하여 GSAP ScrollTrigger의 모든 상태 정보(progress, direction, velocity, pinning)를 실시간으로 자식 컴포넌트에 제공하는 시스템을 구현한다. 이를 통해 ScrollControls와 개별 슬라이드 컴포넌트에서 불필요한 전역 상태 없이 직접적이고 효율적인 GSAP 상태 액세스를 구현한다.

## 현재의 상태 / 문제점

### 현재 구조의 한계

1. **간접적인 데이터 플로우**: SlideGSAPSection → PinningContext → useSectionPinning → 개별 컴포넌트
2. **GSAP 정보 손실**: ScrollTrigger의 `self.progress`, `self.direction`, `self.velocity` 정보가 중간 레이어에서 손실
3. **불필요한 전역 상태**: ScrollControls는 다른 섹션 정보가 필요 없음에도 전역 Context 의존
4. **성능 오버헤드**: Context 업데이트로 인한 불필요한 리렌더링 및 중간 레이어 비용

### 현재 데이터 플로우

```text
SlideGSAPSection → ScrollTrigger callbacks → PinningContext
                                               ↓
                                         useSectionPinning
                                               ↓
                                         Individual Components
```

### 목표 데이터 플로우 (GSAPState Provider)

```text
SlideGSAPSection (GSAPScrollContext.Provider)
    ↓ (direct context)
ScrollControls / Individual Slide Components
    ↓ (useGSAPScroll hook)
Real-time GSAP ScrollTrigger State
```

### GSAP ScrollTrigger에서 제공하는 정보

- `self.progress` (0-1 범위) - 스크롤 진행도
- `self.direction` (1: 전진, -1: 후진) - 스크롤 방향  
- `self.velocity` - 스크롤 속도
- `self.isActive` - ScrollTrigger 활성 상태
- `self.start`, `self.end` - 트리거 시작/종료 위치
- pinning 관련 상태 (isPinned, isEntering, isLeaving)

## 관련 코드의 통합 구조 (Birdeye View)

```text
a2a-demov/
├── src/
│   ├── contexts/
│   │   └── pinning.tsx              # 기존 PinningContext (확장 대상)
│   ├── components/
│   │   ├── Slide/
│   │   │   ├── SlideGSAPSection.tsx # GSAP ScrollTrigger 구현 (수정 대상)
│   │   │   └── GSAPSlidesPage.tsx   # 전체 슬라이드 컨테이너
│   │   ├── DemoView/
│   │   │   └── index.tsx            # A2A 데모 뷰 (연동 대상)
│   │   └── ControlHeader/
│   │       └── ScrollControls.tsx   # 스크롤 기반 제어 (연동 대상)
│   └── hooks/
│       └── useScrollControls.ts     # 스크롤 제어 훅 (확장 대상)
```

### 핵심 연동 포인트

1. **SlideGSAPSection → GSAPScrollContext**: GSAP ScrollTrigger 모든 상태를 실시간 제공
2. **GSAPScrollContext → ScrollControls**: 해당 섹션의 GSAP 상태만 직접 접근
3. **GSAPScrollContext → 개별 슬라이드**: 실시간 scroll progress와 pinning 상태 활용
4. **useGSAPScroll 훅**: 단순하고 직접적인 GSAP 상태 접근

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **직접적인 GSAP 상태 접근**: SlideGSAPSection이 GSAPScrollContext Provider로 동작
2. **실시간 ScrollTrigger 정보**: progress, direction, velocity, pinning 상태 모두 제공
3. **성능 최적화**: 불필요한 전역 상태 제거 및 직접적인 데이터 플로우
4. **개발자 경험**: 간단한 `useGSAPScroll()` 훅으로 모든 GSAP 정보 접근

### 해결 판정 기준

- [ ] SlideGSAPSection이 GSAPScrollContext.Provider로 동작
- [ ] useGSAPScroll 훅이 모든 GSAP ScrollTrigger 정보 제공 (progress, direction, velocity, pinning)
- [ ] ScrollControls가 useGSAPScroll로 해당 섹션의 상태만 접근
- [ ] 개별 슬라이드에서 실시간 scroll progress 기반 애니메이션 구현
- [ ] 기존 useSectionPinning 호환성 유지 (점진적 마이그레이션 지원)

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. Enhanced PinningContext 인터페이스 확장

**파일**: `src/contexts/pinning.tsx`

```typescript
// 기존 인터페이스 확장
export interface EnhancedSectionPinningState extends SectionPinningState {
  // 기존 필드 유지
  isPinned: boolean;
  isEntering: boolean;
  isLeaving: boolean;
  
  // 새로운 scroll progress 필드
  scrollProgress: number;      // 0-1 범위
  scrollDirection: number;     // 1: 전진, -1: 후진, 0: 정지
  scrollVelocity: number;      // 스크롤 속도
  isActive: boolean;           // ScrollTrigger 활성 상태
  startPosition: number;       // 시작 위치
  endPosition: number;         // 종료 위치
  lastUpdate: number;          // 타임스탬프
}

// Context 타입 확장
export interface EnhancedPinningContextType extends PinningContextType {
  states: EnhancedSectionPinningState[];
  
  // 새로운 메서드 추가
  updateScrollProgress: (
    index: number, 
    progress: number, 
    direction: number, 
    velocity: number
  ) => void;
  
  // 전역 스크롤 상태
  globalScrollY: number;
  globalScrollDirection: number;
}
```

### 2. SlideGSAPSection ScrollTrigger 콜백 확장

**파일**: `src/components/Slide/SlideGSAPSection.tsx`

```typescript
// 현재 onUpdate 콜백 확장
...(mobileOptimizations.scrub !== undefined ? {
  onUpdate: (self) => {
    try {
      // 기존 애니메이션 로직
      if (hasTargets(self.animation) && self.progress !== undefined) {
        self.animation.progress(self.progress);
      }
      
      // 새로운 scroll progress 업데이트
      if (updateScrollProgress && sectionIndex != null) {
        updateScrollProgress(
          sectionIndex,
          self.progress || 0,
          self.direction || 0,
          self.velocity || 0
        );
      }
    } catch (error) {
      console.warn('SlideGSAPSection onUpdate error:', error);
    }
  }
} : {})

// onToggle 콜백도 확장
onToggle: (self) => {
  try {
    const isActive = self.isActive;
    const direction = self.direction;

    updateSectionState(sectionIndex, {
      isPinned: pin ? isActive : false,
      isEntering: isActive && direction !== -1,
      isLeaving: !isActive && direction !== 1,
      
      // 새로운 필드 추가
      isActive,
      startPosition: self.start,
      endPosition: self.end,
      lastUpdate: Date.now(),
    });
  } catch (error) {
    console.warn('SlideGSAPSection onToggle error:', error);
  }
}
```

### 3. Enhanced Hook 구현

**파일**: `src/hooks/useEnhancedSectionPinning.ts` (새 파일)

```typescript
export function useEnhancedSectionPinning(sectionIndex: number) {
  const { getSectionState, updateSectionState, updateScrollProgress } = useEnhancedPinning();
  
  const state = getSectionState(sectionIndex);
  
  // 편의 메서드들
  const updatePinningState = useCallback((partialState) => {
    updateSectionState(sectionIndex, partialState);
  }, [sectionIndex, updateSectionState]);
  
  const updateScrollState = useCallback((progress, direction, velocity) => {
    updateScrollProgress(sectionIndex, progress, direction, velocity);
  }, [sectionIndex, updateScrollProgress]);
  
  // 계산된 값들
  const scrollAmount = useMemo(() => Math.round(state.scrollProgress * 100), [state.scrollProgress]);
  const isScrollingDown = state.scrollDirection > 0;
  const isScrollingUp = state.scrollDirection < 0;
  
  return {
    state,
    updatePinningState,
    updateScrollState,
    scrollAmount,        // 0-100 백분율
    isScrollingDown,
    isScrollingUp,
    scrollSpeed: Math.abs(state.scrollVelocity),
    isRapidScroll: Math.abs(state.scrollVelocity) > 1,
  };
}
```

### 4. ScrollControls 연동 강화

**파일**: `src/components/ControlHeader/ScrollControls.tsx`

```typescript
// Enhanced pinning state 활용
export function ScrollControls({
  enabled = true,
  threshold = 30,
  sectionIndex = 0, // 새로운 prop
}: ScrollControlsProps) {
  const { progressNext, revertToPrev, reset, currentScenario } = useScenario();
  
  // Enhanced hook 사용
  const { 
    state, 
    scrollAmount, 
    isScrollingDown, 
    scrollSpeed 
  } = useEnhancedSectionPinning(sectionIndex);

  // 스크롤 속도에 따른 threshold 동적 조정
  const dynamicThreshold = useMemo(() => {
    return scrollSpeed > 1 ? threshold * 0.5 : threshold;
  }, [threshold, scrollSpeed]);

  useScrollControls({
    enabled: enabled && state.isPinned,
    threshold: dynamicThreshold,
    isPinned: state.isPinned,
    onProgressNext: progressNext,
    onRevertToPrev: revertToPrev,
  });

  // 추가 로깅
  useEffect(() => {
    if (state.isPinned) {
      console.log(`ScrollControls: Section ${sectionIndex} - Progress: ${scrollAmount}%`);
    }
  }, [state.isPinned, scrollAmount, sectionIndex]);

  return null;
}
```

## 재사용 가능한 연관 코드

### 기존 호환성 유지 코드

- **`src/contexts/pinning.tsx`**: 기존 인터페이스와 메서드 100% 호환성 유지
- **`src/hooks/useScenario.ts`**: 시나리오 진행 로직 재사용
- **`src/hooks/useScrollControls.ts`**: 스크롤 이벤트 처리 로직 재사용

### 새로운 재사용 컴포넌트

- **`src/hooks/useEnhancedSectionPinning.ts`**: 개별 섹션별 enhanced state 관리
- **`src/utils/scrollCalculations.ts`**: 스크롤 진행도 계산 유틸리티
- **`src/components/shared/ScrollProgressIndicator.tsx`**: 스크롤 진행도 시각화 컴포넌트

### 활용 가능한 인터페이스

```typescript
// 스크롤 진행도 계산
interface ScrollProgressData {
  progress: number;      // 0-1
  percentage: number;    // 0-100
  direction: 'up' | 'down' | 'stationary';
  velocity: number;
  isRapid: boolean;
}

// 섹션 상태 확장
interface SectionDisplayState {
  isPinned: boolean;
  scrollProgress: number;
  visualState: 'entering' | 'active' | 'leaving' | 'inactive';
  animationSpeed: 'slow' | 'normal' | 'fast';
}
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. Context 단위 테스트

**파일**: `src/contexts/__tests__/pinning.test.tsx`

```typescript
describe('Enhanced PinningContext', () => {
  test('기존 pinning 기능 호환성', () => {
    // 기존 isPinned, isEntering, isLeaving 테스트
  });

  test('scroll progress 업데이트', () => {
    // updateScrollProgress 메서드 테스트
    // progress, direction, velocity 값 검증
  });

  test('실시간 상태 동기화', () => {
    // ScrollTrigger 콜백과 Context 상태 동기화 테스트
  });
});
```

### 2. Hook 단위 테스트

**파일**: `src/hooks/__tests__/useEnhancedSectionPinning.test.ts`

```typescript
describe('useEnhancedSectionPinning', () => {
  test('계산된 값들 정확성', () => {
    // scrollAmount, isScrollingDown 등 계산 로직 테스트
  });

  test('성능 최적화 확인', () => {
    // useMemo, useCallback 의존성 배열 테스트
  });
});
```

### 3. 통합 테스트

**파일**: `src/components/Slide/__tests__/SlideGSAPSection.integration.test.tsx`

```typescript
describe('SlideGSAPSection Enhanced Integration', () => {
  test('ScrollTrigger 콜백에서 Context 업데이트', () => {
    // GSAP ScrollTrigger onUpdate/onToggle이 Context를 올바르게 업데이트하는지 확인
  });

  test('DemoView와 ScrollControls 연동', () => {
    // 전체 컴포넌트 트리에서 데이터 플로우 테스트
  });
});
```

### 4. E2E 테스트 시나리오

**파일**: `e2e/scroll-progress.spec.ts`

```typescript
test('Enhanced scroll progress integration', async ({ page }) => {
  // 1. 슬라이드 진입 시 pinning 상태 확인
  // 2. 스크롤 시 progress 값 변화 확인  
  // 3. ScrollControls 반응성 확인
  // 4. DemoView 섹션 업데이트 확인
});
```

## 추가 분석 과제

### 1. 성능 영향 분석

- Context 업데이트 주기가 애니메이션 성능에 미치는 영향 측정
- 모바일 환경에서의 메모리 사용량 최적화 방안

### 2. 스크롤 패턴 분석

- 사용자의 다양한 스크롤 패턴(빠른 스크롤, 느린 스크롤, 역방향)에 대한 대응 전략
- 터치 디바이스에서의 관성 스크롤 처리 방안

### 3. 확장성 고려사항

- 향후 추가될 수 있는 스크롤 기반 기능들(멀티터치, 제스처)에 대한 아키텍처 확장성
- 다른 애니메이션 라이브러리(Framer Motion 등)와의 호환성

---

**예상 작업 시간**: 2-3일  
**우선순위**: 높음 (DemoView 연동 강화를 위한 핵심 기반 작업)  
**리스크**: 낮음 (기존 인터페이스 호환성 유지로 Breaking Changes 없음)
