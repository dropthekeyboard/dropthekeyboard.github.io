# Refactoring Plan: JSON Data URL Asset Deployment Script

**작성일**: 2025-09-24 15:00  
**파일**: ./docs/history/refactoring_20250924_1500.md

## 작업의 목적

디자이너 및 기획자로부터 제공받은 JSON 파일들 내에 포함된 Data URL 형태의 `audioUrl`/`imageUrl` 필드를 실제 파일로 변환하여 `public/assets/` 디렉토리에 배치하고, 해당 URL들을 상대 경로로 치환하는 자동화 스크립트 개발

## 현재의 상태 / 문제점

### 현재 상태

- `input_json/` 폴더에 JSON 파일들이 제공됨 (현재 2개 파일 확인)
- 각 JSON 파일은 시나리오 데이터를 포함하며 `Message` 인터페이스 구조를 따름
- `Message` 객체의 `audioUrl`, `imageUrl` 필드에 Data URL 형태의 데이터가 포함됨
  - `data:audio/mpeg;base64,SUQzBAA...` (MP3 오디오)
  - `data:image/jpeg;base64,/9j/4AAQSkZ...` (JPEG 이미지)
  - `data:image/png;base64,iVBORw0KG...` (PNG 이미지)

### 문제점

- Data URL은 JSON 파일 크기를 급격히 증가시켜 성능 저하 야기
- 브라우저 렌더링 시 매번 base64 디코딩 필요로 인한 성능 오버헤드
- JSON 파일의 가독성 및 디버깅 어려움
- 중복된 미디어 파일의 효율적 관리 불가능
- Git 저장소 용량 증가 및 변경 이력 관리 어려움

## 관련 코드의 통합 구조 (Birdeye View)

```
a2a-demov/
├── input_json/                          # 입력 JSON 파일들 (Data URL 포함)
│   ├── use_case_1_restaurant_reservation_1928.json
│   └── use_case_1_restaurant_reservation_final_음성추가.json
├── public/                              # 정적 파일 배치 디렉토리
│   └── assets/                          # 기존 asset 파일들
│       ├── avatars/
│       ├── product/
│       └── slide/
├── src/
│   ├── contexts/scenario.tsx            # Message 인터페이스 정의
│   ├── data/scenarios.json              # 현재 사용중인 시나리오 데이터
│   └── components/shared/VoiceScreen/   # audioUrl을 사용하는 컴포넌트
├── scripts/                             # 새로 생성될 배포 스크립트 위치
│   └── deploy-assets.ts                 # 배포 스크립트 (생성 필요)
└── package.json                         # 스크립트 실행 명령 추가
```

### 데이터 흐름

1. **입력**: `input_json/*.json` (Data URL 포함)
2. **처리**: 스크립트가 JSON 파싱 → Data URL 추출 → 파일 생성 → URL 치환
3. **출력**: `public/assets/deployed/` (실제 파일들) + 처리된 JSON 파일

### 핵심 인터페이스

- `Message` 인터페이스: `audioUrl?: string`, `imageUrl?: string` 필드 포함
- 시나리오 구조: 재귀적 객체 탐색이 필요한 복잡한 nested 구조

## 변경 이후의 상태 / 해결 판정 기준

### 해결 후 상태

- Data URL이 모두 상대 경로로 치환된 JSON 파일 생성
- `public/assets/deployed/` 디렉토리에 미디어 파일들이 정리됨
- 복수의 입력 JSON이 하나의 통합된 시나리오 JSON으로 병합됨
- 중복 파일 제거 및 효율적인 파일 관리 체계 구축

### 해결 판정 기준

1. **기능적 기준**:
   - 모든 Data URL이 정상적으로 파일로 변환됨
   - 변환된 파일들이 올바른 경로에 배치됨
   - JSON 내 모든 URL 참조가 상대 경로로 정확히 치환됨
   - 복수 JSON 파일이 오류 없이 단일 파일로 병합됨

2. **성능적 기준**:
   - JSON 파일 크기가 90% 이상 감소
   - 중복 파일 자동 제거로 디스크 용량 절약
   - 브라우저 로딩 시간 개선

3. **운영적 기준**:
   - 스크립트 실행 한 번으로 전체 과정 자동화
   - 에러 상황에서 명확한 에러 메시지 제공
   - 기존 파일 덮어쓰기 방지를 위한 안전장치

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 새로운 배포 스크립트 생성: `scripts/deploy-assets.ts`

```typescript
interface AssetFile {
  data: Buffer;
  mimeType: string;
  extension: string;
  hash: string;
}

interface ProcessResult {
  originalUrl: string;
  newUrl: string;
  filePath: string;
}

// 메인 함수 구조
async function deployAssets(
  inputFiles: string[],
  outputPath: string,
  assetDir: string = 'public/assets/deployed'
): Promise<void>;

// 핵심 함수들
function extractDataUrls(obj: any): ProcessResult[];
function saveAssetFiles(assets: AssetFile[], targetDir: string): void;
function replaceUrlsInJson(obj: any, replacements: ProcessResult[]): any;
function mergeScenarios(scenarios: Scenario[]): Scenario;
```

### 2. package.json에 스크립트 명령 추가

```json
{
  "scripts": {
    "deploy-assets": "tsx scripts/deploy-assets.ts",
    "deploy-assets:clean": "rm -rf public/assets/deployed && npm run deploy-assets"
  }
}
```

### 3. 타입 정의 확장 (필요시)

기존 `src/contexts/scenario.tsx`의 `Message` 인터페이스는 이미 `audioUrl?`, `imageUrl?` 필드를 포함하고 있어 추가 수정 불필요

## 재사용 가능한 연관 코드

### 기존 활용 가능한 코드/리소스

- **파일 경로**: `src/contexts/scenario.tsx`
- **주요 기능**: `Message`, `Scenario` 인터페이스 정의
- **인터페이스**: TypeScript 타입 정의가 이미 완벽히 구축됨

- **파일 경로**: `public/assets/avatars/`
- **주요 기능**: 기존 asset 파일 관리 구조 참조
- **활용 방안**: 디렉토리 구조 및 파일명 규칙 참고

### 참고할 기존 패턴

- `src/data/scenarios.json`: 최종 출력 JSON의 구조적 참조점
- Vite 설정: `public/` 디렉토리의 정적 파일 서빙 방식 이해

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 영역

1. **Data URL 파싱 테스트**

   ```typescript
   // scripts/__tests__/deploy-assets.test.ts
   describe('extractDataUrls', () => {
     test('should extract audio data URLs correctly', () => {
       // data:audio/mpeg;base64 형식 테스트
     });

     test('should extract image data URLs correctly', () => {
       // data:image/jpeg, data:image/png 형식 테스트
     });
   });
   ```

2. **파일 생성/저장 테스트**

   ```typescript
   describe('saveAssetFiles', () => {
     test('should create files with correct extensions', () => {
       // MIME type별 확장자 매핑 테스트
     });

     test('should handle duplicate files correctly', () => {
       // 해시 기반 중복 제거 테스트
     });
   });
   ```

3. **JSON 변환 테스트**
   ```typescript
   describe('replaceUrlsInJson', () => {
     test('should replace all data URLs with relative paths', () => {
       // 재귀적 객체 탐색 및 URL 치환 테스트
     });
   });
   ```

### 통합 테스트 영역

- 실제 input_json 파일들을 사용한 end-to-end 테스트
- 생성된 파일들의 브라우저 접근성 테스트
- 대용량 파일 처리 성능 테스트

### 테스트 실행 환경

- Node.js 환경에서의 파일 시스템 조작 테스트
- 임시 디렉토리를 활용한 격리된 테스트 환경 구성

## 추가 고려사항

### 보안 및 안정성

- Data URL 크기 제한 설정 (메모리 오버플로우 방지)
- 악성 파일 유형 검증 (허용된 MIME type만 처리)
- 파일명 sanitization (경로 traversal 공격 방지)

### 확장성

- 추후 다른 Data URL 형식 추가 지원 가능하도록 모듈화
- 다양한 출력 포맷 지원 (단일 파일 vs 시나리오별 분리)
- 설정 파일을 통한 커스터마이징 지원

### 모니터링

- 처리 진행상황 표시 (프로그레스 바)
- 상세한 로깅 (변환된 파일 수, 크기 절약량 등)
- 에러 발생 시 rollback 메커니즘
